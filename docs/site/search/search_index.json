{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Flamingo Documentation\n\n\nWhat is Flamingo\n\n\nA blazing fast modern ecommerce frontend framework with useful packages.\n\n\n\n\nGetting started\n\n\nStart here: \nGetting Started Overview", 
            "title": "Flamingo Documentation"
        }, 
        {
            "location": "/index.html#flamingo-documentation", 
            "text": "", 
            "title": "Flamingo Documentation"
        }, 
        {
            "location": "/index.html#what-is-flamingo", 
            "text": "A blazing fast modern ecommerce frontend framework with useful packages.", 
            "title": "What is Flamingo"
        }, 
        {
            "location": "/index.html#getting-started", 
            "text": "Start here:  Getting Started Overview", 
            "title": "Getting started"
        }, 
        {
            "location": "/0. Introduction/1. Getting Started/index.html", 
            "text": "Getting started with Flamingo\n\n\nDevelopment setup and first steps\n\n\n\n\n\n\nInstall \nGo\n\n\n\n\n\n\nCheck out flamingo traing into \n$GOPATH/src/go.aoe.com/training\n\n(go.aoe.com will be our \nnamespace\n).\n\n\n\n\n\n\n  git clone git@gitlab.aoe.com:shared/flamingo/training.git $GOPATH/src/go.aoe.com/training\n\n\n\n\n\n\n\n\nInstall \ndep\n via \ngo get -u github.com/golang/dep/cmd/dep\n.\nThen download dependencies via \ndep ensure\n.\n(Or \ndep ensure -vendor-only\n for fast and just the necessary dependencies).\n\n\n\n\n\n\nThen run the frontend template build:\n\ncd training/frontend \n yarn \n yarn build\n\n\n\n\n\n\nYou can also start the template dev mode by:\n \nyarn dev\n\n\n\n\nYour entrypoint is \ntraining/training.go\n, this is where the application is started.\n   Run \ngo run training.go\n to see a list of possible commands.\n   Run \ngo run training.go serve\n to start the server\n\n\n\n\nPlease make sure to set your on-save setting to \ngo imports\n in Gogland! (Preferences \n Languages \n Frameworks \n Go \n On Save)\n\n\nHow to start\n\n\nStart with \nHello World Tutorial", 
            "title": "Getting started with Flamingo"
        }, 
        {
            "location": "/0. Introduction/1. Getting Started/index.html#getting-started-with-flamingo", 
            "text": "", 
            "title": "Getting started with Flamingo"
        }, 
        {
            "location": "/0. Introduction/1. Getting Started/index.html#development-setup-and-first-steps", 
            "text": "Install  Go    Check out flamingo traing into  $GOPATH/src/go.aoe.com/training \n(go.aoe.com will be our  namespace ).      git clone git@gitlab.aoe.com:shared/flamingo/training.git $GOPATH/src/go.aoe.com/training    Install  dep  via  go get -u github.com/golang/dep/cmd/dep .\nThen download dependencies via  dep ensure .\n(Or  dep ensure -vendor-only  for fast and just the necessary dependencies).    Then run the frontend template build: cd training/frontend   yarn   yarn build    You can also start the template dev mode by:\n  yarn dev   Your entrypoint is  training/training.go , this is where the application is started.\n   Run  go run training.go  to see a list of possible commands.\n   Run  go run training.go serve  to start the server   Please make sure to set your on-save setting to  go imports  in Gogland! (Preferences   Languages   Frameworks   Go   On Save)", 
            "title": "Development setup and first steps"
        }, 
        {
            "location": "/0. Introduction/1. Getting Started/index.html#how-to-start", 
            "text": "Start with  Hello World Tutorial", 
            "title": "How to start"
        }, 
        {
            "location": "/0. Introduction/2. Tutorial Hello World/index.html", 
            "text": "Hello World Flamingo\n\n\nPreface\n\n\nWe start with a small setup before we will develop our first own module.\n\n\nFlamingo projects consist of an entrypoint (which can be a simple \nflamingo.App\n) to load a context configuration tree.\n\n\nSuch a tree consists of modules which are loaded. A default \nflamingo.App\n routes only a root configuration node,\nhowever more complex projects will need additional setups where we can route anywhere in the tree.\nUsually you'll need something like the \nprefixrouter.Module\n to be able to route complex scenarios with\nconfig inheritance, store-specific dependency injection etc.\n\n\nmain.go\n\n\nWe start with a main go, which will be part of our \ngo.aoe.com/demo/flamingo\n project.\n\n\nPlease create the folder \ndemo/flamingo\n in your \ngo.aoe.com\n folder, and add the following to a \nGopkg.toml\n file:\n\n\n(Please note: markdown can not properly render toml, the \nconstraint\n should be \n[\n \n[\n constraint \n]\n \n]\n )\n\n\n[[constraint]]\n  name = \ngo.aoe.com/flamingo\n\n  branch = \nmaster\n\n\n\n\n\nNow add a \nmain.go\n file:\n\n\npackage main\n\nimport (\n    \ngo.aoe.com/flamingo/core/cmd\n\n    \ngo.aoe.com/flamingo/core/gotemplate\n\n    \ngo.aoe.com/flamingo/core/profiler\n\n    \ngo.aoe.com/flamingo/core/requestlogger\n\n    \ngo.aoe.com/flamingo/framework\n\n    \ngo.aoe.com/flamingo/framework/config\n\n    \ngo.aoe.com/flamingo/framework/dingo\n\n    \ngo.aoe.com/flamingo/framework/flamingo\n\n)\n\n// main is our entry point\nfunc main() {\n    flamingo.App(config.NewArea( // flamingo.App is a quick loader which loads config from the `config` folder\n        \nroot\n, // our root context name\n        []dingo.Module{\n            new(framework.InitModule), // framework initialization\n            new(cmd.Module),           // the cmd module provides command line support\n            new(logrus.Module),        // the logger\n            new(framework.Module),     // flamingo brings some helpful basic tools\n            new(requestlogger.Module), // requestlogger show request logs\n            new(profiler.Module),      // profiler helps to analyze requests etc\n            new(gotemplate.Module),    // gotemplate installls a go template engine (in debug mode, todo fix this)\n        },\n    ), \nconfig\n)\n}\n\n\n\n\nThen run \ndep ensure\n to install flamingo in \nvendor/\n. (To obtain a copy of dep run \ngo get -u github.com/golang/dep/cmd/dep\n.)\n\n\nAlso we need a few templates, go and create a folder \ntemplates/\n in your \ndemo/flamingo/\n folder (\n~/go/src/go.aoe.com/demo/flamingo/templates\n), and put 2 files there:\n\n\n404.html\n\n\nh1\nFile Not Found\n/h1\n\n\nhr/\n\n\npre\n{{ .Error }}\n/pre\n\n\n\n\n\n503.html\n\n\nh1\nServer Error\n/h1\n\n\nhr/\n\n\npre\n{{ .Error }}\n/pre\n\n\n\n\n\nWe need this setup to make the \ngotemplate\n Module not panic due to missing error-templates at all.\n\n\nNow we are ready and can already go to the \nflamingo\n folder and start with \ngo run main.go\n!\n\n\nYou can already start the server with \ngo run main.go serve\n but you'll be stuck with 404 errors for now and maybe template engine errors.\n(Obviously, since we do not have any routes registered.)\n\n\nflamingo.App\n runs by default on port 3322, so go and visit http://localhost:3322/\n\n\nYou'll see log-output like\n\n\n2017/10/16 20:37:24 404 | GET      |       962.792\u00b5s |     53 byte | /\n\n\n\n\nThe log output regarding config files is for information purposes. These places are currently checked for possible configuration files.\n\n\nAlso please note: the gotemplate module does not support subfolders and will reload templates on every request. This is slow and not intended for production!\n\n\nModules\n\n\nNow let's extend our project with a new module!\n\n\nA module in Flamingo is usually in one of five possible locations:\n\n\n\n\nPROJECTNAME\n: This is the place where project modules live (e.g. \"demo/flamingo\")\n\n\nframework\n: This is the Flamingo framework core\n\n\ncore\n: This is the Flamingo core, possibly open-sourced one day, and contains general Flamingo modules\n\n\nom3\n: This is the place where OM3 specific modules go which are generic enough for multiple projects, but not intended for core\n\n\nvendor\n: essentially everything from somewhere else such as github :)\n\n\n\n\nA module always consists of a \nModule\n struct, usually in a file called \nmodule.go\n.\n\n\nThis struct defines the basic module dependencies, such as \nRouterRegistry\n.\n\n\nThe \nModule\n struct has to implement \ndingo.Module\n:\n\n\ntype Module interface {\n  Configure(injector *Injector)\n}\n\n\n\n\nThe \nConfigure\n method is responsible for the dependency injection and module registration.\n\n\nYou can read more in \nDependency Injection\n.\n\n\nOur first module\n\n\nWe start our first module by creating a new subfolder, called \nhelloworld\n (it lives under the \nflamingo/\n folder).\n\n\nIn there we place a file \nmodule.go\n, and enter the following content:\n\n\npackage helloworld\n\nimport \ngo.aoe.com/flamingo/framework/dingo\n\n\ntype Module struct {}\n\nfunc (m *Module) Configure(injector *dingo.Injector){}\n\n\n\n\nNow we register the module by adding it in \nflamingo/main.go\n\n\n//...\n\nimport \ngo.aoe.com/demo/flamingo/helloworld\n\n\n//...\n\nflamingo.App(config.NewArea(\n        \nroot\n,\n        []dingo.Module{\n        // ...\n            new(helloworld.Module),  // add the helloworld module to the end of the list\n        },\n        // ...\n\n\n\n\nNow we have our first module setup in Flamingo :)\n\n\nController\n\n\nLet's try to get some life into it. Controllers work with two parts, \nRoutes\n and \nHandlers\n.\n\n\nA \nRoute\n defines an URL path which is mapped to a controller key, e.g. \n/helloworld\n to \nhelloworld.view\n.\n\n\nA \nHandler\n defines a controller which handles a request to a controller key, e.g. \nhelloworld.view\n handled by \ncontroller.IndexController\n.\n\n\nAbstracting these allows us to rewrite URLs for different locales and easily replace controllers.\n\n\nTo create our IndexController we first need the controller. A controller can implement multiple interfaces:\n\n\n\n\nrouter.GETController\n, called for \nGET\n requests:\n\n\n\n\ntype GETController interface {\n  Get(web.Context) web.Response\n}\n\n\n\n\n\n\nrouter.POSTController\n, called for \nPOST\n requests:\n\n\n\n\ntype POSTController interface {\n  Post(web.Context) web.Response\n}\n\n\n\n\n\n\nfunc(web.Context) web.Response\n, called for any request\n\n\nhttp.Handler\n, called for any request\n\n\n\n\nWe start by creating our controller in the file \ndemo/flamingo/helloworld/interfaces/controller/index.go\n\n\npackage controller\n\nimport (\n    \ngo.aoe.com/flamingo/framework/web\n\n    \nstrings\n\n)\n\n// IndexController to handle /helloworld\ntype IndexController struct{}\n\n// Get handles our GET requests\nfunc (controller *IndexController) Get(ctx web.Context) web.Response {\n    return \nweb.ContentResponse{\n        Body: strings.NewReader(\nHello World!\n),\n    }\n}\n\n\n\n\nOur controller returns a \nContentResponse\n with the \nBody\n set to \nHello World!\n.\n\n\nNow we need to tell Flamingo where to find the controller. We update our \nmodule.go\n,\nadd the \nRouterRegistry\n as a dependency and create a \nRoute\n and a \nHandler\n:\n\n\n(The \nRouterRegistry\n knows everything about routes and controllers. You can inspect it by running \ngo run main.go routes\n)\n\n\npackage helloworld\n\nimport (\n    \ngo.aoe.com/demo/flamingo/helloworld/interfaces/controller\n\n    \ngo.aoe.com/flamingo/framework/dingo\n\n    \ngo.aoe.com/flamingo/framework/router\n\n)\n\ntype Module struct {\n    RouterRegistry *router.Registry `inject:\n`\n}\n\nfunc (m *Module) Configure(injector *dingo.Injector) {\n    m.RouterRegistry.Route(\n/helloworld\n, \nhelloworld.index\n)\n    m.RouterRegistry.Handle(\nhelloworld.index\n, new(controller.IndexController))\n}\n\n\n\n\nNow we start flamingo by running, in the \nflamingo/\n folder, \ngo run main.go serve\n and open \nhttp://localhost:3322/helloworld\n\n\nWe should see our \nHello World!\n response.\n\n\nRender a template\n\n\nThe controller is fine, but we want some fancier content. For this we need a template and tell our Controller to render this template.\n\n\nCurrently we use the \ngotemplate\n module, but obviously this can be anything :) (our main Engine is \npugtemplate\n, please have a look at 3. Tutorial Frontend Templating for Pug templates).\n\n\nTemplating is a topic on it's own, for now we use a simple template \nhelloworld.html\n and place it in \nflamingo/templates/\n:\n\n\nhtml\n\n\nhead\n/head\n\n\nbody\n\n\nh1\nHello {{ .Name }}!\n/h1\n\n\n/body\n\n\n/html\n\n\n\n\n\nNow it's time to render the template. Flamingo has a couple of Responders-helpers, such as:\n\n\n\n\nRenderAware\n (make the Controller render templates)\n\n\nRedirectAware\n (make the Controller redirect to other controllers)\n\n\nErrorAware\n (let the Controller throw errors)\n\n\nJSONAware\n (let the Controller return JSON responses (e.g. for APIs/Ajax-Helpers))\n\n\n\n\nThese make the controller \naware\n of a certain response behaviour, such as \"being aware of \nhow to Render a template\n\".\n\n\nWe make our controller \nRenderAware\n by injecting the corresponding helper into our \nIndexController\n:\n\n\nimport \ngo.aoe.com/flamingo/framework/web/responder\n\n//...\n// IndexController to handle /helloworld\ntype IndexController struct {\n    responder.RenderAware `inject:\n`\n}\n//...\n\n\n\n\nThe \nIndexController\n is now \nRenderAware\n, which means it got a new method \nRender(context web.Context, tpl string, data interface{}) *web.ContentResponse\n\n\nThe \ntpl\n variable is the name of the template, in our case \nhelloworld.html\n. \ndata\n is optional Template data.\n\n\nWe modify our \nIndexController\n accordingly:\n\n\nfunc (controller *IndexController) Get(ctx web.Context) web.Response {\n    return controller.Render(ctx, \nhelloworld\n, struct{Name string}{Name: \nWorld\n})\n}\n\n\n\n\nYay! Great! Now restart the go server \nctrl+c\n, then \ngo run main.go serve\n and you should see the Hello World message! \nHello World\n\n\nYou will also notice a grey gear-wheel at the right bottom corner, clicking there brings you to more detailed information about the request, such as the controller etc.\nThis is the \nprofiler.Module\n we activated in our \nmain.go\n.\n\n\nPath parameters\n\n\n\"Hello World\" is nice, but let's say hello to \"you\".\n\n\nNow we want the \"World\" to be taken from the URL.\n\n\nFirst, we change our route definition like this:\n\n\nm.RouterRegistry.Route(\n/helloworld\n, \nhelloworld.index(name=\\\nWorld\\\n)\n)\nm.RouterRegistry.Route(\n/helloworld/:name\n, \nhelloworld.index(name)\n)\n\n\n\n\nNow \nworld\n is a parameter available to our controller. If we omit the list of parameters in the brackets we get all path parameters.\nIf we have parameters in the list which are not part of the route Flamingo will use GET values to fill them up.\n\n\nWe will now have \n/helloworld\n and \n/helloworld/name\n, routed respectively.\n\n\nWe still default to \nWorld\n, so if nothing is set the controller uses the name \nWorld\n.\n\n\nNow it's time to change our controller to get the request parameter via the request context:\n\n\nfunc (controller *IndexController) Get(ctx web.Context) web.Response {\n    return controller.Render(ctx, \nhelloworld\n, struct{Name string}{Name: ctx.MustParam1(\nname\n)})\n}\n\n\n\n\nNow open \nhttp://localhost:3322/helloworld/\n and compare to \nhttp://localhost:3322/helloworld/you\n\n\nWhen we open our page now, we have a fancy rendered template :)", 
            "title": "Hello World Flamingo"
        }, 
        {
            "location": "/0. Introduction/2. Tutorial Hello World/index.html#hello-world-flamingo", 
            "text": "", 
            "title": "Hello World Flamingo"
        }, 
        {
            "location": "/0. Introduction/2. Tutorial Hello World/index.html#preface", 
            "text": "We start with a small setup before we will develop our first own module.  Flamingo projects consist of an entrypoint (which can be a simple  flamingo.App ) to load a context configuration tree.  Such a tree consists of modules which are loaded. A default  flamingo.App  routes only a root configuration node,\nhowever more complex projects will need additional setups where we can route anywhere in the tree.\nUsually you'll need something like the  prefixrouter.Module  to be able to route complex scenarios with\nconfig inheritance, store-specific dependency injection etc.", 
            "title": "Preface"
        }, 
        {
            "location": "/0. Introduction/2. Tutorial Hello World/index.html#maingo", 
            "text": "We start with a main go, which will be part of our  go.aoe.com/demo/flamingo  project.  Please create the folder  demo/flamingo  in your  go.aoe.com  folder, and add the following to a  Gopkg.toml  file:  (Please note: markdown can not properly render toml, the  constraint  should be  [   [  constraint  ]   ]  )  [[constraint]]\n  name =  go.aoe.com/flamingo \n  branch =  master   Now add a  main.go  file:  package main\n\nimport (\n     go.aoe.com/flamingo/core/cmd \n     go.aoe.com/flamingo/core/gotemplate \n     go.aoe.com/flamingo/core/profiler \n     go.aoe.com/flamingo/core/requestlogger \n     go.aoe.com/flamingo/framework \n     go.aoe.com/flamingo/framework/config \n     go.aoe.com/flamingo/framework/dingo \n     go.aoe.com/flamingo/framework/flamingo \n)\n\n// main is our entry point\nfunc main() {\n    flamingo.App(config.NewArea( // flamingo.App is a quick loader which loads config from the `config` folder\n         root , // our root context name\n        []dingo.Module{\n            new(framework.InitModule), // framework initialization\n            new(cmd.Module),           // the cmd module provides command line support\n            new(logrus.Module),        // the logger\n            new(framework.Module),     // flamingo brings some helpful basic tools\n            new(requestlogger.Module), // requestlogger show request logs\n            new(profiler.Module),      // profiler helps to analyze requests etc\n            new(gotemplate.Module),    // gotemplate installls a go template engine (in debug mode, todo fix this)\n        },\n    ),  config )\n}  Then run  dep ensure  to install flamingo in  vendor/ . (To obtain a copy of dep run  go get -u github.com/golang/dep/cmd/dep .)  Also we need a few templates, go and create a folder  templates/  in your  demo/flamingo/  folder ( ~/go/src/go.aoe.com/demo/flamingo/templates ), and put 2 files there:  404.html  h1 File Not Found /h1  hr/  pre {{ .Error }} /pre   503.html  h1 Server Error /h1  hr/  pre {{ .Error }} /pre   We need this setup to make the  gotemplate  Module not panic due to missing error-templates at all.  Now we are ready and can already go to the  flamingo  folder and start with  go run main.go !  You can already start the server with  go run main.go serve  but you'll be stuck with 404 errors for now and maybe template engine errors.\n(Obviously, since we do not have any routes registered.)  flamingo.App  runs by default on port 3322, so go and visit http://localhost:3322/  You'll see log-output like  2017/10/16 20:37:24 404 | GET      |       962.792\u00b5s |     53 byte | /  The log output regarding config files is for information purposes. These places are currently checked for possible configuration files.  Also please note: the gotemplate module does not support subfolders and will reload templates on every request. This is slow and not intended for production!", 
            "title": "main.go"
        }, 
        {
            "location": "/0. Introduction/2. Tutorial Hello World/index.html#modules", 
            "text": "Now let's extend our project with a new module!  A module in Flamingo is usually in one of five possible locations:   PROJECTNAME : This is the place where project modules live (e.g. \"demo/flamingo\")  framework : This is the Flamingo framework core  core : This is the Flamingo core, possibly open-sourced one day, and contains general Flamingo modules  om3 : This is the place where OM3 specific modules go which are generic enough for multiple projects, but not intended for core  vendor : essentially everything from somewhere else such as github :)   A module always consists of a  Module  struct, usually in a file called  module.go .  This struct defines the basic module dependencies, such as  RouterRegistry .  The  Module  struct has to implement  dingo.Module :  type Module interface {\n  Configure(injector *Injector)\n}  The  Configure  method is responsible for the dependency injection and module registration.  You can read more in  Dependency Injection .", 
            "title": "Modules"
        }, 
        {
            "location": "/0. Introduction/2. Tutorial Hello World/index.html#our-first-module", 
            "text": "We start our first module by creating a new subfolder, called  helloworld  (it lives under the  flamingo/  folder).  In there we place a file  module.go , and enter the following content:  package helloworld\n\nimport  go.aoe.com/flamingo/framework/dingo \n\ntype Module struct {}\n\nfunc (m *Module) Configure(injector *dingo.Injector){}  Now we register the module by adding it in  flamingo/main.go  //...\n\nimport  go.aoe.com/demo/flamingo/helloworld \n\n//...\n\nflamingo.App(config.NewArea(\n         root ,\n        []dingo.Module{\n        // ...\n            new(helloworld.Module),  // add the helloworld module to the end of the list\n        },\n        // ...  Now we have our first module setup in Flamingo :)", 
            "title": "Our first module"
        }, 
        {
            "location": "/0. Introduction/2. Tutorial Hello World/index.html#controller", 
            "text": "Let's try to get some life into it. Controllers work with two parts,  Routes  and  Handlers .  A  Route  defines an URL path which is mapped to a controller key, e.g.  /helloworld  to  helloworld.view .  A  Handler  defines a controller which handles a request to a controller key, e.g.  helloworld.view  handled by  controller.IndexController .  Abstracting these allows us to rewrite URLs for different locales and easily replace controllers.  To create our IndexController we first need the controller. A controller can implement multiple interfaces:   router.GETController , called for  GET  requests:   type GETController interface {\n  Get(web.Context) web.Response\n}   router.POSTController , called for  POST  requests:   type POSTController interface {\n  Post(web.Context) web.Response\n}   func(web.Context) web.Response , called for any request  http.Handler , called for any request   We start by creating our controller in the file  demo/flamingo/helloworld/interfaces/controller/index.go  package controller\n\nimport (\n     go.aoe.com/flamingo/framework/web \n     strings \n)\n\n// IndexController to handle /helloworld\ntype IndexController struct{}\n\n// Get handles our GET requests\nfunc (controller *IndexController) Get(ctx web.Context) web.Response {\n    return  web.ContentResponse{\n        Body: strings.NewReader( Hello World! ),\n    }\n}  Our controller returns a  ContentResponse  with the  Body  set to  Hello World! .  Now we need to tell Flamingo where to find the controller. We update our  module.go ,\nadd the  RouterRegistry  as a dependency and create a  Route  and a  Handler :  (The  RouterRegistry  knows everything about routes and controllers. You can inspect it by running  go run main.go routes )  package helloworld\n\nimport (\n     go.aoe.com/demo/flamingo/helloworld/interfaces/controller \n     go.aoe.com/flamingo/framework/dingo \n     go.aoe.com/flamingo/framework/router \n)\n\ntype Module struct {\n    RouterRegistry *router.Registry `inject: `\n}\n\nfunc (m *Module) Configure(injector *dingo.Injector) {\n    m.RouterRegistry.Route( /helloworld ,  helloworld.index )\n    m.RouterRegistry.Handle( helloworld.index , new(controller.IndexController))\n}  Now we start flamingo by running, in the  flamingo/  folder,  go run main.go serve  and open  http://localhost:3322/helloworld  We should see our  Hello World!  response.", 
            "title": "Controller"
        }, 
        {
            "location": "/0. Introduction/2. Tutorial Hello World/index.html#render-a-template", 
            "text": "The controller is fine, but we want some fancier content. For this we need a template and tell our Controller to render this template.  Currently we use the  gotemplate  module, but obviously this can be anything :) (our main Engine is  pugtemplate , please have a look at 3. Tutorial Frontend Templating for Pug templates).  Templating is a topic on it's own, for now we use a simple template  helloworld.html  and place it in  flamingo/templates/ :  html  head /head  body  h1 Hello {{ .Name }}! /h1  /body  /html   Now it's time to render the template. Flamingo has a couple of Responders-helpers, such as:   RenderAware  (make the Controller render templates)  RedirectAware  (make the Controller redirect to other controllers)  ErrorAware  (let the Controller throw errors)  JSONAware  (let the Controller return JSON responses (e.g. for APIs/Ajax-Helpers))   These make the controller  aware  of a certain response behaviour, such as \"being aware of  how to Render a template \".  We make our controller  RenderAware  by injecting the corresponding helper into our  IndexController :  import  go.aoe.com/flamingo/framework/web/responder \n//...\n// IndexController to handle /helloworld\ntype IndexController struct {\n    responder.RenderAware `inject: `\n}\n//...  The  IndexController  is now  RenderAware , which means it got a new method  Render(context web.Context, tpl string, data interface{}) *web.ContentResponse  The  tpl  variable is the name of the template, in our case  helloworld.html .  data  is optional Template data.  We modify our  IndexController  accordingly:  func (controller *IndexController) Get(ctx web.Context) web.Response {\n    return controller.Render(ctx,  helloworld , struct{Name string}{Name:  World })\n}  Yay! Great! Now restart the go server  ctrl+c , then  go run main.go serve  and you should see the Hello World message!  Hello World  You will also notice a grey gear-wheel at the right bottom corner, clicking there brings you to more detailed information about the request, such as the controller etc.\nThis is the  profiler.Module  we activated in our  main.go .", 
            "title": "Render a template"
        }, 
        {
            "location": "/0. Introduction/2. Tutorial Hello World/index.html#path-parameters", 
            "text": "\"Hello World\" is nice, but let's say hello to \"you\".  Now we want the \"World\" to be taken from the URL.  First, we change our route definition like this:  m.RouterRegistry.Route( /helloworld ,  helloworld.index(name=\\ World\\ ) )\nm.RouterRegistry.Route( /helloworld/:name ,  helloworld.index(name) )  Now  world  is a parameter available to our controller. If we omit the list of parameters in the brackets we get all path parameters.\nIf we have parameters in the list which are not part of the route Flamingo will use GET values to fill them up.  We will now have  /helloworld  and  /helloworld/name , routed respectively.  We still default to  World , so if nothing is set the controller uses the name  World .  Now it's time to change our controller to get the request parameter via the request context:  func (controller *IndexController) Get(ctx web.Context) web.Response {\n    return controller.Render(ctx,  helloworld , struct{Name string}{Name: ctx.MustParam1( name )})\n}  Now open  http://localhost:3322/helloworld/  and compare to  http://localhost:3322/helloworld/you  When we open our page now, we have a fancy rendered template :)", 
            "title": "Path parameters"
        }, 
        {
            "location": "/0. Introduction/3. Tutorial Frontend Templating/index.html", 
            "text": "Flamingo Frontend Development\n\n\nThis has been moved to \"carotene-cli\" documentation.", 
            "title": "Flamingo Frontend Development"
        }, 
        {
            "location": "/0. Introduction/3. Tutorial Frontend Templating/index.html#flamingo-frontend-development", 
            "text": "This has been moved to \"carotene-cli\" documentation.", 
            "title": "Flamingo Frontend Development"
        }, 
        {
            "location": "/1. Developing/1_Structure/index.html", 
            "text": "Flamingo Project Structure\n\n\nflamingo (Project Root)\n\u2502   README.md\n\u2502   Dockerfile\n\u2502   Makefile\n\u2502   Jenkinsfile\n\u2502   Gopkg.lock\n\u2502   Gopkg.toml\n\u2502\n\u2514\u2500\u2500\u2500PROJECTNAME\n\u2502   \u2502   PROJECTNAME.go (Main executable)\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500config (Main project config)\n\u2502   \u2514\u2500\u2500\u2500src (Project specific packages go here)       \n\u2502   \n\u2514\u2500\u2500\u2500core (Core packages are loaded here)\n\u2502   \u2514\u2500\u2500\u2500auth\n\u2502   \u2514\u2500\u2500\u2500cms\n\u2502   \u2514\u2500\u2500\u2500product\n\u2502\n\u2514\u2500\u2500\u2500framework (Framework packages go here)\n\u2502   \u2514\u2500\u2500\u2500router\n\u2502   \u2514\u2500\u2500\u2500web\n\u2502\n\u2514\u2500\u2500\u2500om3 (OM3 related packages go here)\n\u2502\n\u2514\u2500\u2500\u2500... (Optional additional packages can be grouped)\n\n\n\n\n\nPROJECTNAME structure\n\n\nNormaly this is where all the project specific stuff belongs to.\n(Name it like you want)\n\n\nThe Main executable should do:\n\n build the context tree for your project\n\n start the root command (delegate work to core/cmd package)\n\n\nConfiguration Context\n\n\nA configuration context allows to run several different flamingo powered sites in one installation.\nTypical usecases are localisations and/or specific subsites.\n\n\nA Context represents:\n\n a list of modules for each context\n\n configurations (that are loaded from the coresponsing \"config\" folder)\n\n a baseurl: This is the first part of the URL - and its telling flamingo which context should be loaded.\n\n Contexts can be nested in a tree like structure - this allows you to inherit the properties of contexts from parents to childs", 
            "title": "Flamingo Project Structure"
        }, 
        {
            "location": "/1. Developing/1_Structure/index.html#flamingo-project-structure", 
            "text": "flamingo (Project Root)\n\u2502   README.md\n\u2502   Dockerfile\n\u2502   Makefile\n\u2502   Jenkinsfile\n\u2502   Gopkg.lock\n\u2502   Gopkg.toml\n\u2502\n\u2514\u2500\u2500\u2500PROJECTNAME\n\u2502   \u2502   PROJECTNAME.go (Main executable)\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500config (Main project config)\n\u2502   \u2514\u2500\u2500\u2500src (Project specific packages go here)       \n\u2502   \n\u2514\u2500\u2500\u2500core (Core packages are loaded here)\n\u2502   \u2514\u2500\u2500\u2500auth\n\u2502   \u2514\u2500\u2500\u2500cms\n\u2502   \u2514\u2500\u2500\u2500product\n\u2502\n\u2514\u2500\u2500\u2500framework (Framework packages go here)\n\u2502   \u2514\u2500\u2500\u2500router\n\u2502   \u2514\u2500\u2500\u2500web\n\u2502\n\u2514\u2500\u2500\u2500om3 (OM3 related packages go here)\n\u2502\n\u2514\u2500\u2500\u2500... (Optional additional packages can be grouped)", 
            "title": "Flamingo Project Structure"
        }, 
        {
            "location": "/1. Developing/1_Structure/index.html#projectname-structure", 
            "text": "Normaly this is where all the project specific stuff belongs to.\n(Name it like you want)  The Main executable should do:  build the context tree for your project  start the root command (delegate work to core/cmd package)", 
            "title": "PROJECTNAME structure"
        }, 
        {
            "location": "/1. Developing/1_Structure/index.html#configuration-context", 
            "text": "A configuration context allows to run several different flamingo powered sites in one installation.\nTypical usecases are localisations and/or specific subsites.  A Context represents:  a list of modules for each context  configurations (that are loaded from the coresponsing \"config\" folder)  a baseurl: This is the first part of the URL - and its telling flamingo which context should be loaded.  Contexts can be nested in a tree like structure - this allows you to inherit the properties of contexts from parents to childs", 
            "title": "Configuration Context"
        }, 
        {
            "location": "/1. Developing/2_Ports and Adapters/index.html", 
            "text": "", 
            "title": "2 Ports and Adapters"
        }, 
        {
            "location": "/1. Developing/4_Testing/index.html", 
            "text": "Testing\n\n\nGo Testing\n\n\nIn go you place your tests directly in the package.\nYou can simply use the standard go testing tool.\n\n\nTo run tests of a certain package simply run the \ngo test\n tool.\nFor example:\n\n\ngo test -v flamingo/core/cart/domain/\n\n\n\n\nGinkgo\n\n\nMost of Flamingo's package use \nGingko\n for BDD based testing.\n\n\nTake a look at the Dingo test suite to get an idea about the tests.\n\n\nTesting with Pact\n\n\nSome tests are using Pact - so you need to prepare the test run:\nRead on \n5_Test and Mock external services.md\n.", 
            "title": "Testing"
        }, 
        {
            "location": "/1. Developing/4_Testing/index.html#testing", 
            "text": "", 
            "title": "Testing"
        }, 
        {
            "location": "/1. Developing/4_Testing/index.html#go-testing", 
            "text": "In go you place your tests directly in the package.\nYou can simply use the standard go testing tool.  To run tests of a certain package simply run the  go test  tool.\nFor example:  go test -v flamingo/core/cart/domain/", 
            "title": "Go Testing"
        }, 
        {
            "location": "/1. Developing/4_Testing/index.html#ginkgo", 
            "text": "Most of Flamingo's package use  Gingko  for BDD based testing.  Take a look at the Dingo test suite to get an idea about the tests.", 
            "title": "Ginkgo"
        }, 
        {
            "location": "/1. Developing/4_Testing/index.html#testing-with-pact", 
            "text": "Some tests are using Pact - so you need to prepare the test run:\nRead on  5_Test and Mock external services.md .", 
            "title": "Testing with Pact"
        }, 
        {
            "location": "/1. Developing/5_Test and Mock external services/index.html", 
            "text": "Testing and Mocking external Services\n\n\n\n\nNode\n\n\nThis section explains mocking in flamingo backend.\n\n\nThis section does not cover the templaing only mocks - please see \nTutorial Frontend Templating\n\n\n\n\nIntroduction / Context\n\n\nAn important role of Flamingo is to consume external services - often via REST APIs.\n\n\nFlamingo is a \nConsumer\n of Services provided by a \nProvider\n\n\nDuring development you usally want to fake or mock this external services. So lets clearify the naming:\n\n\n\n\nFaking:\n  Means instead of Calling the actual API we are faking a result internal, e.g. by using an implementation that dont calls an API but just answers with (fixed) faked results.\n\n\nMocking:\n Means we try to use the real code that later (in production) should call the real service. But instead of using the real service we call a seperate mock. This mock need to run.\n\n\n\n\nFaking is good for start. Mocking is the right way if you want more production like development setup.\n\n\nContract Testing\n\n\nIf you use a Mock, then someone should verify that the Mock behaves like the real Service (or the other way around).\nThis is what is called contract testing.\nYou should establish this.\n\n\nConsumer Based Contract Testing\n\n\nIn case you have control over the provider you can use consumer based contract testing.\nThat means that a contract test provided by flamingo is executed in the build pipeline of the provider.\n\n\nWe support pact for this.\n\n\nFaking in Flamingo\n\n\nThe \nPorts and Adapters\n concept allows to register a \"fake\" implementation.\n\n\nAdding the fake implementation:\n\n\n###PROJECT###\n\u2502---fakeservices\n     |--- servicepackagename\n     |     |---- service.go\n     |module.go\n\n\n\n\nIn module.go register the fake implementation:\n\n\ninjector.Override((*productdomain.BrandService)(nil), \n).To(product.FakeService{})\n\n\n\n\nBetter is to make this even configurable. And then add feature flags to your configuration in dev context (context_dev.yml).\nThis way you automatically use the fake implementation when starting flamingo in \nCONTEXT\n dev.\n\n\nThere are ready to use fakeservices in some modules (e.g. om3/fakeservices or sometime in the module itself)\n\n\nMocking in Flamingo\n\n\nGetting started with Pact\n\n\nRead more about Pact here: https://docs.pact.io/\n\n\nPact tests rely on pact_go (https://github.com/pact-foundation/pact-go/) and flamingo comes with a \"testutil\" package with useful functions to work with pact.\n\n\nSo you might need to have the Pact daemon running:\n\n\n\n\nInstall pact_go ( https://github.com/pact-foundation/pact-go/#installation )\n\n\nRun \npact-go daemon\n. Now you have the daemon running on default port 6666\n\n\n\n\nCheckout the example - e.g. in the package \n\"magento\"", 
            "title": "Testing and Mocking external Services"
        }, 
        {
            "location": "/1. Developing/5_Test and Mock external services/index.html#testing-and-mocking-external-services", 
            "text": "Node  This section explains mocking in flamingo backend.  This section does not cover the templaing only mocks - please see  Tutorial Frontend Templating", 
            "title": "Testing and Mocking external Services"
        }, 
        {
            "location": "/1. Developing/5_Test and Mock external services/index.html#introduction-context", 
            "text": "An important role of Flamingo is to consume external services - often via REST APIs.  Flamingo is a  Consumer  of Services provided by a  Provider  During development you usally want to fake or mock this external services. So lets clearify the naming:   Faking:   Means instead of Calling the actual API we are faking a result internal, e.g. by using an implementation that dont calls an API but just answers with (fixed) faked results.  Mocking:  Means we try to use the real code that later (in production) should call the real service. But instead of using the real service we call a seperate mock. This mock need to run.   Faking is good for start. Mocking is the right way if you want more production like development setup.", 
            "title": "Introduction / Context"
        }, 
        {
            "location": "/1. Developing/5_Test and Mock external services/index.html#contract-testing", 
            "text": "If you use a Mock, then someone should verify that the Mock behaves like the real Service (or the other way around).\nThis is what is called contract testing.\nYou should establish this.", 
            "title": "Contract Testing"
        }, 
        {
            "location": "/1. Developing/5_Test and Mock external services/index.html#consumer-based-contract-testing", 
            "text": "In case you have control over the provider you can use consumer based contract testing.\nThat means that a contract test provided by flamingo is executed in the build pipeline of the provider.  We support pact for this.", 
            "title": "Consumer Based Contract Testing"
        }, 
        {
            "location": "/1. Developing/5_Test and Mock external services/index.html#faking-in-flamingo", 
            "text": "The  Ports and Adapters  concept allows to register a \"fake\" implementation.  Adding the fake implementation:  ###PROJECT###\n\u2502---fakeservices\n     |--- servicepackagename\n     |     |---- service.go\n     |module.go  In module.go register the fake implementation:  injector.Override((*productdomain.BrandService)(nil),  ).To(product.FakeService{})  Better is to make this even configurable. And then add feature flags to your configuration in dev context (context_dev.yml).\nThis way you automatically use the fake implementation when starting flamingo in  CONTEXT  dev.  There are ready to use fakeservices in some modules (e.g. om3/fakeservices or sometime in the module itself)", 
            "title": "Faking in Flamingo"
        }, 
        {
            "location": "/1. Developing/5_Test and Mock external services/index.html#mocking-in-flamingo", 
            "text": "", 
            "title": "Mocking in Flamingo"
        }, 
        {
            "location": "/1. Developing/5_Test and Mock external services/index.html#getting-started-with-pact", 
            "text": "Read more about Pact here: https://docs.pact.io/  Pact tests rely on pact_go (https://github.com/pact-foundation/pact-go/) and flamingo comes with a \"testutil\" package with useful functions to work with pact.  So you might need to have the Pact daemon running:   Install pact_go ( https://github.com/pact-foundation/pact-go/#installation )  Run  pact-go daemon . Now you have the daemon running on default port 6666   Checkout the example - e.g. in the package  \"magento\"", 
            "title": "Getting started with Pact"
        }, 
        {
            "location": "/2. Framework Features/configuration concept/index.html", 
            "text": "Configuration\n\n\nBasics\n\n\nConfigurations are yml files located in \nconfig\n folder.\n\n\nThe configuration syntax is to specify areas either with \n.\n or as yaml maps:\n\n\nfoo:\n  bar: x\n\n\n\n\nis the same as\n\n\nfoo.bar: x\n\n\n\n\nConfiguration can be used (either by the \nconfig()\n helper, or via dependency injection.\nAsking for either a concrete value via e.g. \nfoo.bar\n is possible, as well as getting a whole \nconfig.Map\n instance by a partially-selector, e.g. \nfoo\n.\nThis would be a Map with element \nbar\n set to \nx\n.\n\n\nDeeply nested config maps can be marshaled into structs for convenience.\n\n\nThe result struct must match exactly the structure and types of the config map and all fields must be exported.\n\n\nerr := m.MarshalTo(\nresult)\n\n\n\n\nThere is a root configuration \"context.yml\".\n\n\nYou can set different CONTEXT with the environment variable \nCONTEXT\n and this will cause flamingo to load another configuration file.\n\n\ne.g. starting flamingo with\n\n\n  export CONTEXT=\ndev\n \n go run project.go serve\n\n\n\n\nWill cause flamingo to load the configfile \"config/context_dev.yml\"\n\n\nConfiguration values can be read from environment variables with the syntax:\n\n\n  auth.secret: '%%ENV:KEYCLOAK_SECRET%%'\n\n\n\n\nConfiguration Context Areas\n\n\nYou can have several configuration areas in your project.\n\n\nConfiguration areas have:\n\n a name\n\n a list of modules to load\n\n a baseurl that will cause flamingo to \"detect\" and use that configuration area\n\n child config areas\n\n\nWith the concept of having childs, the config areas in your project can form a tree. Inside the tree most of the configurations and modules are inherited to the childrens.\n\n\nThis concept is mainly used to configure different websites/channels with different locales for example.\n\n\nBackground informations\n\n\nConfigurations are defined and used by the individual modules. \nThe modules should come with a documentation which configurations/featureflags they support.\n\n\nDependency injection\n is used to inject configuration values.", 
            "title": "Configuration"
        }, 
        {
            "location": "/2. Framework Features/configuration concept/index.html#configuration", 
            "text": "", 
            "title": "Configuration"
        }, 
        {
            "location": "/2. Framework Features/configuration concept/index.html#basics", 
            "text": "Configurations are yml files located in  config  folder.  The configuration syntax is to specify areas either with  .  or as yaml maps:  foo:\n  bar: x  is the same as  foo.bar: x  Configuration can be used (either by the  config()  helper, or via dependency injection.\nAsking for either a concrete value via e.g.  foo.bar  is possible, as well as getting a whole  config.Map  instance by a partially-selector, e.g.  foo .\nThis would be a Map with element  bar  set to  x .  Deeply nested config maps can be marshaled into structs for convenience.  The result struct must match exactly the structure and types of the config map and all fields must be exported.  err := m.MarshalTo( result)  There is a root configuration \"context.yml\".  You can set different CONTEXT with the environment variable  CONTEXT  and this will cause flamingo to load another configuration file.  e.g. starting flamingo with    export CONTEXT= dev    go run project.go serve  Will cause flamingo to load the configfile \"config/context_dev.yml\"  Configuration values can be read from environment variables with the syntax:    auth.secret: '%%ENV:KEYCLOAK_SECRET%%'", 
            "title": "Basics"
        }, 
        {
            "location": "/2. Framework Features/configuration concept/index.html#configuration-context-areas", 
            "text": "You can have several configuration areas in your project.  Configuration areas have:  a name  a list of modules to load  a baseurl that will cause flamingo to \"detect\" and use that configuration area  child config areas  With the concept of having childs, the config areas in your project can form a tree. Inside the tree most of the configurations and modules are inherited to the childrens.  This concept is mainly used to configure different websites/channels with different locales for example.", 
            "title": "Configuration Context Areas"
        }, 
        {
            "location": "/2. Framework Features/configuration concept/index.html#background-informations", 
            "text": "Configurations are defined and used by the individual modules. \nThe modules should come with a documentation which configurations/featureflags they support.  Dependency injection  is used to inject configuration values.", 
            "title": "Background informations"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html", 
            "text": "Dingo Dependency Injection\n\n\nAbout dependency injection\n\n\nIn general we suggest using Dependency Injection Pattern - this Patterns means nothing more than\nif your object requires collaboration with others, then expect the user (or client)\nof your object to set this dependencies from outside.\n\n\nTo use this pattern you don't need a seperate dependency injection container. \nBut using this approach gives you higher testability and often leads to a cleaner and flexible architecture.\nTypical \"things\" that can be injected are services, repositories or factories. If your object just expects a certain\n\"interface\" the user/client of your object can decide what concrete object it wants your object to use.\n\n\nIt might sound like a \"hen \n-\n egg\" problem - because someone has to decide on the concrete instance that should\nbe injected.\n\n\nSo somewhere it need to start - and someone needs to inject the correct dependencies to your object - right?\nThis can be for example:\n- the orchestration logic (normaly in the application layer) deciding which instance(s) to inject.\nYou can achive this without any framework support.\n- a dependency registration concept - where you allow also other packages to influence which object should be injected.\nThis normaly requires a dependency injection container in the framework.\n\n\nDI Container in Flamingo\n\n\nFlamingo Framework comes with a DI Container called Dingo.\n\n\nThe Container acts as kind of registry for services (objects of any type), factories and parameters.\nThe container can then return (or resolve) objects and can inject depenendcies automatically with some magic involved.\n\n\nIt is mainly used in the core for:\n- managing different contexts and stateful objects (like routing) in the contexts\n- registering ports and adapters\n- ...\n\n\nHello Dingo\n\n\nDingo works very very similiar to \nGuice\n\n\nBasically one binds implementations/factories to interfaces, which are then resolved by Dingo.\n\n\nGiven that Dingo's idea is based on Guice we use similar examples in this documentation:\n\n\nThe following example shows a BillingService with two injected dependencies. Please note\nthat Go's nature does not allow contructors, and does not allow decorations/annotations\nbeside struct-tags, thus, we only use struct tags (and later arguments for providers).\n\n\nAlso Go does not have a way to reference types (like Java's \nSomething.class\n) we use \nnil\n\nand cast it to a pointer to the interface we want to specify: \n(*Something)(nil)\n.\nDingo then knowns how to dereference it properly and derive the correct type \nSomething\n.\nThis is not necessary for structs, where we can just use the null value via \nSomething{}\n.\n\n\ntype BillingService struct {\n    Processor CreditCardProcessor `inject:\n`\n    TransactionLog TransactionLog `inject:\n`\n}\n\nfunc (billingservice *BillingService) ChargeOrder(order PizzaOrder, creditCard CreditCard) Receipt {\n    // ...\n}\n\n\n\n\nWe want the BillingService to get certain dependencies, and configure this in a \nBillingModule\n\nwhich implements \ndingo.Module\n:\n\n\ntype BillingModule struct {}\n\nfunc (module *BillingModule) Configure(injector *dingo.Injector) {\n     /*\n      * This tells Dingo that whenever it sees a dependency on a TransactionLog,\n      * it should satisfy the dependency using a DatabaseTransactionLog.\n      */\n    injector.Bind((*TransactionLog)(nil)).To(DatabaseTransactionLog{})\n\n     /*\n      * Similarly, this binding tells Dingo that when CreditCardProcessor is used in\n      * a dependency, that should be satisfied with a PaypalCreditCardProcessor.\n      */\n    injector.Bind((*CreditCardProcessor)(nil)).To(PaypalCreditCardProcessor{})\n  }\n}\n\n\n\n\nThe modules provide information to Dingo on how to build the injection tree, and at the topmost level\nthe injector is created and used in the following way:\n\n\npackage main\n\nimport \ngo.aoe.com/flamingo/framework/dingo\n\n\nfunc main() {\n  var injector = dingo.NewInjector()\n\n  // The injector can be initialized by modules:\n  injector.InitModules(new(BillingModule))\n\n  /*\n   * Now that we've got the injector, we can build objects.\n   * We get a new instance, and cast it accordingly:\n   */\n  var billingService = injector.GetInstance((*BillingService)(nil)).(BillingService)\n  //...\n}\n\n\n\n\nA module itself can ask for dependencies, e.g.\n\n\ntype Module struct {\n    RouterRegistry *router.Registry `inject:\n`\n}\n\nfunc (m *Module) Configure(injector *dingo.Inject) {\n    m.RouterRegistry.Route(\n/home\n, \nhome()\n)\n}\n\n\n\n\nBindings\n\n\nDingo uses bindings to express dependencies resolutions, and will panic if there is more than one\nbinding for a type with the same name (or unnamed), unless you use multibindings.\n\n\nBind\n\n\nBind creates a new binding, and tells Dingo how to resolve the type when it encounters a request for this type.\nBindings can chain, but need to implement the correct interfaces.\n\n\ninjector.Bind((*Something)(nil))\n\n\n\n\nAnnotatedWith\n\n\nBy default a binding is unnamend, and thus requested with the \ninject:\"\"\n tag.\n\n\nHowever you can name bindings to have more concrete kinds of it. Using \nAnnotatedWith\n you can specify the name:\n\n\ninjector.Bind((*Something)(nil)).AnnotatedWith(\nmyAnnotation\n)\n\n\n\n\nIt is requested via the \ninject:\"myAnnotation\"\n tag.\n\n\nTo\n\n\nTo defines which type should be created when this type is requested.\nThis can be an Interface which implements to one it is bound to, or a concrete type.\nThe type is then created via \nreflect.New\n.\n\n\ninjector.Bind((*Something)(nil)).To(MyType{})\n\n\n\n\nToProvider\n\n\nIf you want a factory to create your types then you rather use \nToProvider\n instead of \nTo\n.\n\n\nToProvider\n is a function which returns an instance (which again will go thru Dingo to fill dependencies).\n\n\nAlso the provider can request arguments from Dingo which are necessary to construct the bounded type.\nIf you need named arguments (e.g. a string instance annotated with a configuration value) you need to request\nan instance of an object with these annotations, because Go does not allow to pass any meta-information on function\narguments.\n\n\nfunc MyTypeProvider(se SomethingElse) *MyType {\n    return \nMyType{\n        Special: se.DoSomething(),\n    }\n}\n\ninjector.Bind((*Something)(nil)).ToProvider(MyTypeProvider)\n\n\n\n\nThis example will make Dingo call \nMyTypeProvider\n and pass in an instance of \nSomethingElse\n as it's first argument,\nthen take the result of \n*MyType\n as the value for \nSomething\n.\n\n\nToProvider\n takes precedence over \nTo\n.\n\n\nToInstance\n\n\nFor situations where you have one, and only one, concrete instance you can use \nToInstance\n to bind\nsomething to the concrete instance. This is not the same as a Singleton!\n(Even though the resuting behaviour is very similar.)\n\n\nvar myInstance = new(MyType)\nmyInstance.Connect(somewhere)\ninjector.Bind((*Something)(nil)).ToInstance(myInstance)\n\n\n\n\nYou can also bind an instance it to a struct obviously, not only to interfaces.\n\n\nToInstance\n takes precedence over both \nTo\n and \nToProvider\n.\n\n\nIn\n\n\nIn\n allows us to bind in a scope, making the created instances scoped in a certain way.\n\n\nCurrently Dingo only allows to bind to \ndingo.Singleton\n and \ndingo.ChildSingleton\n.\n\n\ninjector.Bind((*Something)(nil)).In(dingo.Singleton).To(MyType{})\n\n\n\n\ndingo.Singleton\n\n\nThe \ndingo.Singleton\n scope makes sure a dependency is only resolved once, and the result is\nreused. Because the Singleton needs synchronisation for types over multiple concurrent\ngoroutines and make sure that a Singleton is only created once, the initial creation\ncan be costly and also the injection of a Singleton is always taking more resources than creation\nof an immutable new object.\n\n\nThe synchronisation is done on multiple levels, a first test tries to find the singleton,\nif that is not possible a lock-mechanism via a scoped Mutex takes care of delegating\nthe concrete creation to one goroutine via a scope+type specific Mutex which then generates\nthe Singleton and makes it available to other currently waiting injection requests, as\nwell as future injection requests.\n\n\nBy default it is advised to not use Singletons whenever possible, and rather use\nimmutable objects you inject whenever you need them.\n\n\ndingo.ChildSingleton\n\n\nThe ChildSingleton is just another Singleton (actually of the same type), but dingo will create a new one\nfor every derived child injector.\n\n\nThis allows frameworks like Flamingo to distinguish at a root level between singleton scopes, e.g. for\nmulti-page setups where we need a wide scope for routers.\n\n\nSince ChildSingleton is very similar to Singleton you should only use it with care.\n\n\nAsEagerSingleton\n\n\nSingleton creation is always costly due to synchronisation overhead, therefore\nDingo bindings allow to mark a binding \nAsEagerSingleton\n.\n\n\nThis makes sure the Singleton is created as soon as possible, before the rest of the Application\nruns. \nAsEagerSingleton\n implies \nIn(dingo.Singleton)\n.\n\n\ninjector.Bind((*Something)(nil)).To(MyType{}).AsEagerSingleton()\n\n\n\n\nIt is also possible to bind a concrete type without \nTo\n:\n\n\ninjector.Bind(MyType{}).AsEagerSingleton()\n\n\n\n\nBinding this type as an eager singleton inject the singleton instance whenever \nMyType\n is requested. \nMyType\n is a concrete type (struct) here, so we can use this mechanism to create an instance explicitly before the application is run.\n\n\nOverride\n\n\nIn rare cases you might have to override an existing binding, which can be done with \nOverride\n:\n\n\ninjector.Override((*Something)(nil), \n).To(MyBetterType{})\n\n\n\n\nOverride\n also returns a binding such as \nBind\n, but removes the original binding.\n\n\nThe second argument sets the annotation if you want to override a named binding.\n\n\nMultiBindings\n\n\nMultiBindings provide a way of binding multiple implementations of a type to a type,\nmaking the injection a list.\n\n\nEssentially this means that multiple modules are able to register for a type, and a user of this\ntype can request an injection of \n[]T\n to get a list of all registered bindings.\n\n\ninjector.BindMulti((*Something)(nil)).To(MyType1{})\ninjector.BindMulti((*Something)(nil)).To(MyType2{})\n\nstruct {\n    List []Something `inject:\n`  // List is a slice of []Something{MyType1{}, MyType2{}}\n}\n\n\n\n\nMultiBindings are used to allow multiple modules to register for a certain type, such as a list of\nencoders, subscribers, etc.\n\n\nPlease not that MultiBindings are not always a clear pattern, as it might hide certain complexity.\n\n\nUsually it is easier to request some kind of a registry in your module, and then register explicitly.\n\n\nRequesting injection\n\n\nDingo uses struct tags to allow structs to request injection into fields.\n\n\nAs stated earlier this is the only Go-way to make annotations, everything else is not supported!\n\n\nFor every requested injection (unless an exception applies) Dingo does the following:\n\n\n\n\nIs there a binding? If so: delegate to the binding\n\n\nIs the binding in a certain scope (Singleton)? If so, delegate to scope (might result in a new loop)\n\n\nBinding is bound to an instance: inject instance\n\n\nBinding is bound to a provider: call provider\n\n\nBinding is bound to a type: request injection of this type (might return in a new loop to resolve the binding)\n\n\nNo binding? Try to create (only possible for concrete types, not interfaces or functions)\n\n\n\n\nOptional injection\n\n\nAn injection struct tag can be marked as optional by adding the suffix \n,optional\n to it.\nThis means that for interfaces, slices, pointers etc where dingo can not resolve a concrete type, the \nnil\n-type is injected.\n\n\nYou can check via \nif my.Prop == nil\n if this is nil.\n\n\nMultiBindings\n\n\nInjection of multibindings:\n\n\nstruct {\n    ListOfTypes []Type `inject:\n`\n}\n\n\n\n\nAnnotatedWith\n\n\nInjection of annotated values:\n\n\nstruct {\n    PaypalPaymentProcessor PaymentProcessor `inject:\nPaypal\n`\n}\n\n\n\n\nProvider\n\n\nDingo allows to request the injection of provider instead of instances.\n\n\nstruct {\n    PizzaProvider func() Pizza `inject:\n`\n}\n\n\n\n\nIf there is no concrete binding to the type \nfunc() Pizza\n, then instead of constructing one \nPizza\n instance\nDingo will create a new function which, on every call, will return a new instance of \nPizza\n.\n\n\nThe type must be of \nfunc() T\n, a function without any arguments which returns a type, which again has a binding.\n\n\nThis allows to lazily create new objects whenever needed, instead of requesting the Dingo injector itself.\n\n\nFor example:\n\n\nfunc createSomething(factoryDependency SomethingElse) Something{\n    return \nMyType{}\n}\n\ninjector.Bind((*Something)(nil)).ToProvider(createSomething)\n\nstruct {\n    SomethingProvider func() Something `inject:\n`\n}\n\n\n\n\nwill essentially call \ncreateSomething(new(SomethingElse))\n everytime \nSomethingProvider()\n is called,\npassing the resulting instance thru the injection to finalize uninjected fields. \n\n\nHow and Where \"injection\" can be used\n\n\nEvery instance that is created through the container can use injection. \nTo get instances injected you just have to use the \"inject\" annotation inside of structs like this:\n\n\ntype RenderAware struct {\n    Router *router.Router  `inject:\n`\n    Engine template.Engine `inject:\n`\n}\n\n\n\n\nWhen to use the depencency injection container in flamingo\n\n\n\n\nIt is ok to not use the dependency injection container. In fact overusing the container adds unneccessary complexity.\nWhen writing a package you should think of beeing able to also use it without the container\n So it is ok to:\n\n\nExplicitly initialize your object yourself and decide in the application layer what to inject (if you use dependency injection)\n\n\nExplicitly use your own factory directly \n\n\n\n\n\n\nEvery object that has a state that is depending on the running configuration-context, e.g. in a project where multiple configuration-contexts exist, should be injected,\nbecause every configuration-context has its own initialized container the di container takes care of giving you\nthe correct initialized instance.\n\n\nFor example the Router ( \n*responder.RenderAware `inject:\"\"`\n )\n\n\nAlso for settings/parameters/configurations  \n\n\n\n\n\n\nAlso the DI Container is used get the \"right\" interface implementation - in order to implement a flexible\n\"Ports and Adapters\" concept (see below)\n\n\n\n\nPorts and Adapters with the Container\n\n\nBasti: Wouln't it be cool \n\n\nBinding basic types\n\n\nDingo allows binding values to \nint\n, \nstring\n etc., such as with any other type.\n\n\nThis can be used to inject configuration values.\n\n\nFlamingo makes an annotated binding of every configuration value in the form of:\n\n\nvar Configuration map[string]interface{}\n\nfor k, v := range Configuration {\n    injector.Bind(v).AnnotatedWith(\nconfig:\n + k).ToInstance(v)\n}\n\n\n\n\nIn this case Dingo learns the actual type of \nv\n (such as string, bool, int) and provides the annotated injection.\n\n\nLater this can be used via\n\n\nstruct {\n    ConfigParam string `inject:\nconfig:myconfigParam\n`\n}\n\n\n\n\nDingo Interception\n\n\nDingo allows modules to bind interceptors for interfaces.\n\n\nEssentially this means that whenever the injection of a certain type is happening,\nthe interceptor is injected instead with the actual injection injected into the interceptor's\nfirst field. This mechanism can only work for interface interception.\n\n\nMultiple interceptors stack upon each other.\n\n\nInterception should be used with care!\n\n\nfunc (m *Module) Configure(injector *dingo.Injector) {\n    injector.BindInterceptor((*template.Engine)(nil), TplInterceptor{})\n    injector.BindInterceptor((*template.Function)(nil), FunctionInterceptor{})\n}\n\ntype (\n    TplInterceptor struct {\n        template.Engine\n    }\n\n    FunctionInterceptor struct {\n        template.Function\n    }\n)\n\nfunc (t *TplInterceptor) Render(context web.Context, name string, data interface{}) io.Reader {\n    log.Println(\nBefore Rendering\n, name)\n    start := time.Now()\n    r := t.Engine.Render(context, name, data)\n    log.Println(\nAfter Rendering\n, time.Since(start))\n    return r\n}\n\nfunc (f *FunctionInterceptor) Name() string {\n    funcname := f.Function.Name()\n    log.Println(\nFunction\n, funcname, \nused\n)\n    return funcname\n}", 
            "title": "Dingo Dependency Injection"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#dingo-dependency-injection", 
            "text": "", 
            "title": "Dingo Dependency Injection"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#about-dependency-injection", 
            "text": "In general we suggest using Dependency Injection Pattern - this Patterns means nothing more than\nif your object requires collaboration with others, then expect the user (or client)\nof your object to set this dependencies from outside.  To use this pattern you don't need a seperate dependency injection container. \nBut using this approach gives you higher testability and often leads to a cleaner and flexible architecture.\nTypical \"things\" that can be injected are services, repositories or factories. If your object just expects a certain\n\"interface\" the user/client of your object can decide what concrete object it wants your object to use.  It might sound like a \"hen  -  egg\" problem - because someone has to decide on the concrete instance that should\nbe injected.  So somewhere it need to start - and someone needs to inject the correct dependencies to your object - right?\nThis can be for example:\n- the orchestration logic (normaly in the application layer) deciding which instance(s) to inject.\nYou can achive this without any framework support.\n- a dependency registration concept - where you allow also other packages to influence which object should be injected.\nThis normaly requires a dependency injection container in the framework.", 
            "title": "About dependency injection"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#di-container-in-flamingo", 
            "text": "Flamingo Framework comes with a DI Container called Dingo.  The Container acts as kind of registry for services (objects of any type), factories and parameters.\nThe container can then return (or resolve) objects and can inject depenendcies automatically with some magic involved.  It is mainly used in the core for:\n- managing different contexts and stateful objects (like routing) in the contexts\n- registering ports and adapters\n- ...", 
            "title": "DI Container in Flamingo"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#hello-dingo", 
            "text": "Dingo works very very similiar to  Guice  Basically one binds implementations/factories to interfaces, which are then resolved by Dingo.  Given that Dingo's idea is based on Guice we use similar examples in this documentation:  The following example shows a BillingService with two injected dependencies. Please note\nthat Go's nature does not allow contructors, and does not allow decorations/annotations\nbeside struct-tags, thus, we only use struct tags (and later arguments for providers).  Also Go does not have a way to reference types (like Java's  Something.class ) we use  nil \nand cast it to a pointer to the interface we want to specify:  (*Something)(nil) .\nDingo then knowns how to dereference it properly and derive the correct type  Something .\nThis is not necessary for structs, where we can just use the null value via  Something{} .  type BillingService struct {\n    Processor CreditCardProcessor `inject: `\n    TransactionLog TransactionLog `inject: `\n}\n\nfunc (billingservice *BillingService) ChargeOrder(order PizzaOrder, creditCard CreditCard) Receipt {\n    // ...\n}  We want the BillingService to get certain dependencies, and configure this in a  BillingModule \nwhich implements  dingo.Module :  type BillingModule struct {}\n\nfunc (module *BillingModule) Configure(injector *dingo.Injector) {\n     /*\n      * This tells Dingo that whenever it sees a dependency on a TransactionLog,\n      * it should satisfy the dependency using a DatabaseTransactionLog.\n      */\n    injector.Bind((*TransactionLog)(nil)).To(DatabaseTransactionLog{})\n\n     /*\n      * Similarly, this binding tells Dingo that when CreditCardProcessor is used in\n      * a dependency, that should be satisfied with a PaypalCreditCardProcessor.\n      */\n    injector.Bind((*CreditCardProcessor)(nil)).To(PaypalCreditCardProcessor{})\n  }\n}  The modules provide information to Dingo on how to build the injection tree, and at the topmost level\nthe injector is created and used in the following way:  package main\n\nimport  go.aoe.com/flamingo/framework/dingo \n\nfunc main() {\n  var injector = dingo.NewInjector()\n\n  // The injector can be initialized by modules:\n  injector.InitModules(new(BillingModule))\n\n  /*\n   * Now that we've got the injector, we can build objects.\n   * We get a new instance, and cast it accordingly:\n   */\n  var billingService = injector.GetInstance((*BillingService)(nil)).(BillingService)\n  //...\n}  A module itself can ask for dependencies, e.g.  type Module struct {\n    RouterRegistry *router.Registry `inject: `\n}\n\nfunc (m *Module) Configure(injector *dingo.Inject) {\n    m.RouterRegistry.Route( /home ,  home() )\n}", 
            "title": "Hello Dingo"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#bindings", 
            "text": "Dingo uses bindings to express dependencies resolutions, and will panic if there is more than one\nbinding for a type with the same name (or unnamed), unless you use multibindings.", 
            "title": "Bindings"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#bind", 
            "text": "Bind creates a new binding, and tells Dingo how to resolve the type when it encounters a request for this type.\nBindings can chain, but need to implement the correct interfaces.  injector.Bind((*Something)(nil))", 
            "title": "Bind"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#annotatedwith", 
            "text": "By default a binding is unnamend, and thus requested with the  inject:\"\"  tag.  However you can name bindings to have more concrete kinds of it. Using  AnnotatedWith  you can specify the name:  injector.Bind((*Something)(nil)).AnnotatedWith( myAnnotation )  It is requested via the  inject:\"myAnnotation\"  tag.", 
            "title": "AnnotatedWith"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#to", 
            "text": "To defines which type should be created when this type is requested.\nThis can be an Interface which implements to one it is bound to, or a concrete type.\nThe type is then created via  reflect.New .  injector.Bind((*Something)(nil)).To(MyType{})", 
            "title": "To"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#toprovider", 
            "text": "If you want a factory to create your types then you rather use  ToProvider  instead of  To .  ToProvider  is a function which returns an instance (which again will go thru Dingo to fill dependencies).  Also the provider can request arguments from Dingo which are necessary to construct the bounded type.\nIf you need named arguments (e.g. a string instance annotated with a configuration value) you need to request\nan instance of an object with these annotations, because Go does not allow to pass any meta-information on function\narguments.  func MyTypeProvider(se SomethingElse) *MyType {\n    return  MyType{\n        Special: se.DoSomething(),\n    }\n}\n\ninjector.Bind((*Something)(nil)).ToProvider(MyTypeProvider)  This example will make Dingo call  MyTypeProvider  and pass in an instance of  SomethingElse  as it's first argument,\nthen take the result of  *MyType  as the value for  Something .  ToProvider  takes precedence over  To .", 
            "title": "ToProvider"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#toinstance", 
            "text": "For situations where you have one, and only one, concrete instance you can use  ToInstance  to bind\nsomething to the concrete instance. This is not the same as a Singleton!\n(Even though the resuting behaviour is very similar.)  var myInstance = new(MyType)\nmyInstance.Connect(somewhere)\ninjector.Bind((*Something)(nil)).ToInstance(myInstance)  You can also bind an instance it to a struct obviously, not only to interfaces.  ToInstance  takes precedence over both  To  and  ToProvider .", 
            "title": "ToInstance"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#in", 
            "text": "In  allows us to bind in a scope, making the created instances scoped in a certain way.  Currently Dingo only allows to bind to  dingo.Singleton  and  dingo.ChildSingleton .  injector.Bind((*Something)(nil)).In(dingo.Singleton).To(MyType{})", 
            "title": "In"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#dingosingleton", 
            "text": "The  dingo.Singleton  scope makes sure a dependency is only resolved once, and the result is\nreused. Because the Singleton needs synchronisation for types over multiple concurrent\ngoroutines and make sure that a Singleton is only created once, the initial creation\ncan be costly and also the injection of a Singleton is always taking more resources than creation\nof an immutable new object.  The synchronisation is done on multiple levels, a first test tries to find the singleton,\nif that is not possible a lock-mechanism via a scoped Mutex takes care of delegating\nthe concrete creation to one goroutine via a scope+type specific Mutex which then generates\nthe Singleton and makes it available to other currently waiting injection requests, as\nwell as future injection requests.  By default it is advised to not use Singletons whenever possible, and rather use\nimmutable objects you inject whenever you need them.", 
            "title": "dingo.Singleton"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#dingochildsingleton", 
            "text": "The ChildSingleton is just another Singleton (actually of the same type), but dingo will create a new one\nfor every derived child injector.  This allows frameworks like Flamingo to distinguish at a root level between singleton scopes, e.g. for\nmulti-page setups where we need a wide scope for routers.  Since ChildSingleton is very similar to Singleton you should only use it with care.", 
            "title": "dingo.ChildSingleton"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#aseagersingleton", 
            "text": "Singleton creation is always costly due to synchronisation overhead, therefore\nDingo bindings allow to mark a binding  AsEagerSingleton .  This makes sure the Singleton is created as soon as possible, before the rest of the Application\nruns.  AsEagerSingleton  implies  In(dingo.Singleton) .  injector.Bind((*Something)(nil)).To(MyType{}).AsEagerSingleton()  It is also possible to bind a concrete type without  To :  injector.Bind(MyType{}).AsEagerSingleton()  Binding this type as an eager singleton inject the singleton instance whenever  MyType  is requested.  MyType  is a concrete type (struct) here, so we can use this mechanism to create an instance explicitly before the application is run.", 
            "title": "AsEagerSingleton"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#override", 
            "text": "In rare cases you might have to override an existing binding, which can be done with  Override :  injector.Override((*Something)(nil),  ).To(MyBetterType{})  Override  also returns a binding such as  Bind , but removes the original binding.  The second argument sets the annotation if you want to override a named binding.", 
            "title": "Override"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#multibindings", 
            "text": "MultiBindings provide a way of binding multiple implementations of a type to a type,\nmaking the injection a list.  Essentially this means that multiple modules are able to register for a type, and a user of this\ntype can request an injection of  []T  to get a list of all registered bindings.  injector.BindMulti((*Something)(nil)).To(MyType1{})\ninjector.BindMulti((*Something)(nil)).To(MyType2{})\n\nstruct {\n    List []Something `inject: `  // List is a slice of []Something{MyType1{}, MyType2{}}\n}  MultiBindings are used to allow multiple modules to register for a certain type, such as a list of\nencoders, subscribers, etc.  Please not that MultiBindings are not always a clear pattern, as it might hide certain complexity.  Usually it is easier to request some kind of a registry in your module, and then register explicitly.", 
            "title": "MultiBindings"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#requesting-injection", 
            "text": "Dingo uses struct tags to allow structs to request injection into fields.  As stated earlier this is the only Go-way to make annotations, everything else is not supported!  For every requested injection (unless an exception applies) Dingo does the following:   Is there a binding? If so: delegate to the binding  Is the binding in a certain scope (Singleton)? If so, delegate to scope (might result in a new loop)  Binding is bound to an instance: inject instance  Binding is bound to a provider: call provider  Binding is bound to a type: request injection of this type (might return in a new loop to resolve the binding)  No binding? Try to create (only possible for concrete types, not interfaces or functions)", 
            "title": "Requesting injection"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#optional-injection", 
            "text": "An injection struct tag can be marked as optional by adding the suffix  ,optional  to it.\nThis means that for interfaces, slices, pointers etc where dingo can not resolve a concrete type, the  nil -type is injected.  You can check via  if my.Prop == nil  if this is nil.", 
            "title": "Optional injection"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#multibindings_1", 
            "text": "Injection of multibindings:  struct {\n    ListOfTypes []Type `inject: `\n}", 
            "title": "MultiBindings"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#annotatedwith_1", 
            "text": "Injection of annotated values:  struct {\n    PaypalPaymentProcessor PaymentProcessor `inject: Paypal `\n}", 
            "title": "AnnotatedWith"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#provider", 
            "text": "Dingo allows to request the injection of provider instead of instances.  struct {\n    PizzaProvider func() Pizza `inject: `\n}  If there is no concrete binding to the type  func() Pizza , then instead of constructing one  Pizza  instance\nDingo will create a new function which, on every call, will return a new instance of  Pizza .  The type must be of  func() T , a function without any arguments which returns a type, which again has a binding.  This allows to lazily create new objects whenever needed, instead of requesting the Dingo injector itself.  For example:  func createSomething(factoryDependency SomethingElse) Something{\n    return  MyType{}\n}\n\ninjector.Bind((*Something)(nil)).ToProvider(createSomething)\n\nstruct {\n    SomethingProvider func() Something `inject: `\n}  will essentially call  createSomething(new(SomethingElse))  everytime  SomethingProvider()  is called,\npassing the resulting instance thru the injection to finalize uninjected fields.", 
            "title": "Provider"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#how-and-where-injection-can-be-used", 
            "text": "Every instance that is created through the container can use injection. \nTo get instances injected you just have to use the \"inject\" annotation inside of structs like this:  type RenderAware struct {\n    Router *router.Router  `inject: `\n    Engine template.Engine `inject: `\n}", 
            "title": "How and Where \"injection\" can be used"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#when-to-use-the-depencency-injection-container-in-flamingo", 
            "text": "It is ok to not use the dependency injection container. In fact overusing the container adds unneccessary complexity.\nWhen writing a package you should think of beeing able to also use it without the container\n So it is ok to:  Explicitly initialize your object yourself and decide in the application layer what to inject (if you use dependency injection)  Explicitly use your own factory directly     Every object that has a state that is depending on the running configuration-context, e.g. in a project where multiple configuration-contexts exist, should be injected,\nbecause every configuration-context has its own initialized container the di container takes care of giving you\nthe correct initialized instance.  For example the Router (  *responder.RenderAware `inject:\"\"`  )  Also for settings/parameters/configurations      Also the DI Container is used get the \"right\" interface implementation - in order to implement a flexible\n\"Ports and Adapters\" concept (see below)", 
            "title": "When to use the depencency injection container in flamingo"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#ports-and-adapters-with-the-container", 
            "text": "Basti: Wouln't it be cool", 
            "title": "Ports and Adapters with the Container"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#binding-basic-types", 
            "text": "Dingo allows binding values to  int ,  string  etc., such as with any other type.  This can be used to inject configuration values.  Flamingo makes an annotated binding of every configuration value in the form of:  var Configuration map[string]interface{}\n\nfor k, v := range Configuration {\n    injector.Bind(v).AnnotatedWith( config:  + k).ToInstance(v)\n}  In this case Dingo learns the actual type of  v  (such as string, bool, int) and provides the annotated injection.  Later this can be used via  struct {\n    ConfigParam string `inject: config:myconfigParam `\n}", 
            "title": "Binding basic types"
        }, 
        {
            "location": "/2. Framework Features/dependency-injection/index.html#dingo-interception", 
            "text": "Dingo allows modules to bind interceptors for interfaces.  Essentially this means that whenever the injection of a certain type is happening,\nthe interceptor is injected instead with the actual injection injected into the interceptor's\nfirst field. This mechanism can only work for interface interception.  Multiple interceptors stack upon each other.  Interception should be used with care!  func (m *Module) Configure(injector *dingo.Injector) {\n    injector.BindInterceptor((*template.Engine)(nil), TplInterceptor{})\n    injector.BindInterceptor((*template.Function)(nil), FunctionInterceptor{})\n}\n\ntype (\n    TplInterceptor struct {\n        template.Engine\n    }\n\n    FunctionInterceptor struct {\n        template.Function\n    }\n)\n\nfunc (t *TplInterceptor) Render(context web.Context, name string, data interface{}) io.Reader {\n    log.Println( Before Rendering , name)\n    start := time.Now()\n    r := t.Engine.Render(context, name, data)\n    log.Println( After Rendering , time.Since(start))\n    return r\n}\n\nfunc (f *FunctionInterceptor) Name() string {\n    funcname := f.Function.Name()\n    log.Println( Function , funcname,  used )\n    return funcname\n}", 
            "title": "Dingo Interception"
        }, 
        {
            "location": "/2. Framework Features/events/index.html", 
            "text": "Events\n\n\nFlamingo uses a builtin event router, which routes events for each request.\n\n\nThis means that events are request-scoped, so you can assume that fired events should not\ncross request boundaries (and are bound to the same go routine).\n\n\nEvent interfaces\n\n\nAn Event can be everything, usually a struct with a few fields.\n\n\nLoginSucessEvent struct {\n    UserId string\n}\n\n\n\n\nFiring events\n\n\nOn the Context\n\n\nAn Event is fired on the request via \ncontext.EventRouter().Dispatch(ctx, event)\n.\n\n\ntype (\n    IndexController struct {}\n\n    MyEvent struct {\n        Data string\n    }\n)\n\nfunc (controller *IndexController) Get(ctx web.Context) web.Response {\n    ctx.EventRouter().Dispatch(ctx, \nMyEvent{Data: \nHello\n})\n}\n\n\n\n\nSubscribing to events\n\n\nTo listen to Events you need to create a \"Subscriber\". \nA Subscriber will get all Events and need to decide which Events it want to handle:\n\n\ntype (\n    type EventSubscriber struct {}\n)\n\n//Implement Subscriber Interface\nfunc (subscriber *EventSubscriber) Notify(event event.Event) {\n    switch event := event.(type) {\n    case *MyEvent:\n        subscriber.OnMyEvent(event)  // call event handler\n    }\n}\n\n\n\n\nCurrently Flamingo uses Dingo Multibindings to register Event Subscriber\n\n\nfunc (m *Module) Configure(injector *dingo.Injector) {\n    injector.BindMulti((*event.Subscriber)(nil)).To(EventSubscriber{})\n}", 
            "title": "Events"
        }, 
        {
            "location": "/2. Framework Features/events/index.html#events", 
            "text": "Flamingo uses a builtin event router, which routes events for each request.  This means that events are request-scoped, so you can assume that fired events should not\ncross request boundaries (and are bound to the same go routine).", 
            "title": "Events"
        }, 
        {
            "location": "/2. Framework Features/events/index.html#event-interfaces", 
            "text": "An Event can be everything, usually a struct with a few fields.  LoginSucessEvent struct {\n    UserId string\n}", 
            "title": "Event interfaces"
        }, 
        {
            "location": "/2. Framework Features/events/index.html#firing-events", 
            "text": "", 
            "title": "Firing events"
        }, 
        {
            "location": "/2. Framework Features/events/index.html#on-the-context", 
            "text": "An Event is fired on the request via  context.EventRouter().Dispatch(ctx, event) .  type (\n    IndexController struct {}\n\n    MyEvent struct {\n        Data string\n    }\n)\n\nfunc (controller *IndexController) Get(ctx web.Context) web.Response {\n    ctx.EventRouter().Dispatch(ctx,  MyEvent{Data:  Hello })\n}", 
            "title": "On the Context"
        }, 
        {
            "location": "/2. Framework Features/events/index.html#subscribing-to-events", 
            "text": "To listen to Events you need to create a \"Subscriber\". \nA Subscriber will get all Events and need to decide which Events it want to handle:  type (\n    type EventSubscriber struct {}\n)\n\n//Implement Subscriber Interface\nfunc (subscriber *EventSubscriber) Notify(event event.Event) {\n    switch event := event.(type) {\n    case *MyEvent:\n        subscriber.OnMyEvent(event)  // call event handler\n    }\n}  Currently Flamingo uses Dingo Multibindings to register Event Subscriber  func (m *Module) Configure(injector *dingo.Injector) {\n    injector.BindMulti((*event.Subscriber)(nil)).To(EventSubscriber{})\n}", 
            "title": "Subscribing to events"
        }, 
        {
            "location": "/2. Framework Features/flaming_vs_idiomatic_go/index.html", 
            "text": "Flaming vs. Idiomatic Go\n\n\nA few notes where Flamingo currently is not idiomatic Go, and why those decisions were made.\n\n\nflamingo\n package, no vendor/VCS prefix\n\n\nFlamingo currently is not installable via \ngo get\n, this is due to the mono-repository approach,\ninternal technical dependencies and because it saves work at time.\n\n\nHowever, this might change in the futures.\n\n\nFlamingo \"Framework\"\n\n\nGo has a great standard library for doing web stuff, and a lot of packages/libraries provide\nHTTP routing, template rendering, config parsing, etc. etc.\nFlamingo tries to be compatible with everything (starting with \nhttp.Handler\n) and tries to enforce\nas few special/non-idiomatic behaviours as possible, however it is designed for bigger projects\nthan the usual microservice, with a pluggable module system and facing challenges in web-environments\nwhich other frameworks don't have (for example a lot of Go web-frameworks provide great support for\nREST-like url patterns, but they don't integrate too well in a SEO-ish, dynamic infrastructure where\na lot of different functionality needs to be adopted).\n\n\nAfter all this is not to be seen as a Framework, rather helping pieces to make your software work.\n\n\nDependency Injection / IOC\n\n\nWhile Go itself is trying to make everything visible, Dependency Injection usually adds magic\nand hides complexity, and what actually happens. Flamingo tries to keep this as little as possible,\nbut using the pluggable architecture it is a necessary part of how everything works.\n\n\nNo MVC\n\n\nAs stated earlier Flamingo is not a Framework, especially not a full MVC framework.\n\n\nInstead developers are supposed to have as much freedom as possible, therefore opinionated parts are\nkept to a minimum.\n\n\nNotes:\n\n\nAfter all, Flamingo\n- Does not generate code.\n- Does not cut compatibility with \nhttp.Handler\n.\n- (Almost) limits reflection to the DI component.\n- Tries to have as much as possible in code, and as less as possible in config files.\n- Does not use reflection for controller invokation.\n- Tries to keep dependencies to the core framework as little as possible.", 
            "title": "Flaming vs. Idiomatic Go"
        }, 
        {
            "location": "/2. Framework Features/flaming_vs_idiomatic_go/index.html#flaming-vs-idiomatic-go", 
            "text": "A few notes where Flamingo currently is not idiomatic Go, and why those decisions were made.", 
            "title": "Flaming vs. Idiomatic Go"
        }, 
        {
            "location": "/2. Framework Features/flaming_vs_idiomatic_go/index.html#flamingo-package-no-vendorvcs-prefix", 
            "text": "Flamingo currently is not installable via  go get , this is due to the mono-repository approach,\ninternal technical dependencies and because it saves work at time.  However, this might change in the futures.", 
            "title": "flamingo package, no vendor/VCS prefix"
        }, 
        {
            "location": "/2. Framework Features/flaming_vs_idiomatic_go/index.html#flamingo-framework", 
            "text": "Go has a great standard library for doing web stuff, and a lot of packages/libraries provide\nHTTP routing, template rendering, config parsing, etc. etc.\nFlamingo tries to be compatible with everything (starting with  http.Handler ) and tries to enforce\nas few special/non-idiomatic behaviours as possible, however it is designed for bigger projects\nthan the usual microservice, with a pluggable module system and facing challenges in web-environments\nwhich other frameworks don't have (for example a lot of Go web-frameworks provide great support for\nREST-like url patterns, but they don't integrate too well in a SEO-ish, dynamic infrastructure where\na lot of different functionality needs to be adopted).  After all this is not to be seen as a Framework, rather helping pieces to make your software work.", 
            "title": "Flamingo \"Framework\""
        }, 
        {
            "location": "/2. Framework Features/flaming_vs_idiomatic_go/index.html#dependency-injection-ioc", 
            "text": "While Go itself is trying to make everything visible, Dependency Injection usually adds magic\nand hides complexity, and what actually happens. Flamingo tries to keep this as little as possible,\nbut using the pluggable architecture it is a necessary part of how everything works.", 
            "title": "Dependency Injection / IOC"
        }, 
        {
            "location": "/2. Framework Features/flaming_vs_idiomatic_go/index.html#no-mvc", 
            "text": "As stated earlier Flamingo is not a Framework, especially not a full MVC framework.  Instead developers are supposed to have as much freedom as possible, therefore opinionated parts are\nkept to a minimum.", 
            "title": "No MVC"
        }, 
        {
            "location": "/2. Framework Features/flaming_vs_idiomatic_go/index.html#notes", 
            "text": "After all, Flamingo\n- Does not generate code.\n- Does not cut compatibility with  http.Handler .\n- (Almost) limits reflection to the DI component.\n- Tries to have as much as possible in code, and as less as possible in config files.\n- Does not use reflection for controller invokation.\n- Tries to keep dependencies to the core framework as little as possible.", 
            "title": "Notes:"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html", 
            "text": "Routing\n\n\nRouting concept\n\n\nThe URL structure in flamingo consists of a baseurl + the rest of the url.\nThe baseurl is matched against the configured contexts and determines the context that should be loaded.\n\n\nFor the part of the url behind the baseurl (=path) a standard routing concept is applied, where at the end the URL is matched to a controller.\n\n\n\n\na route is assigned to a handle. (A handle is a string that represents a unique name). A handle can be something like \"cms.page.view\"\n\n\nfor a handle a Controller can be registered. The indirection through handles allows us to register different controllers for certain handlers in different contexts.\n\n\n\n\nRoutes can be configured the following ways:\n\n Via \nrouter.Registry\n in \nmodule.go\n\n\n As part of the project configuration. This again allows us to have different routing paths configured for different contexts.\n\n\nRoute\n\n\nA route defines a mapping from a path to an handler identifier.\n\n\nThe handler identifier is used to easily support reverse routing and rewriting mechanisms.\n\n\nHandler\n\n\nA handler is defined by mapping a path to a \nhttp.Handler\n or a controller.\n\n\nController types\n\n\n\n\nhttp.Handler\n: will call \nServeHTTP\n for requests matching the route\n\n\nGETController\n: will call \nGet(web.Context) web.Response\n for \nGET\n Requests\n\n\nPOSTController\n: will call \nPost(web.Context) web.Response\n for \nPOST\n Requests\n\n\nHEADController\n: will call \nHead(web.Context) web.Response\n for \nHEAD\n Requests\n\n\nDELETEController\n: will call \nDelete(web.Context) web.Response\n for \nDELETE\n Requests\n\n\nPUTController\n: will call \nPut(web.Context) web.Response\n for \nPUT\n Requests\n\n\nfunc(web.Context) web.Response\n: called for any Request\n\n\nDataController\n: will call \nData(web.Context) interface{}\n for Data requests\n\n\nfunc(web.Context) interface{}\n: for Data requests\n\n\n\n\nData Controller\n\n\nViews can request arbitrary data via the \nget\n template function.\n\n\nFlamingo exposes these data controllers via their logical name at \n/_flamingo/json?name=...\n.\nThis is a default feature for Ajax-based cache holepunching etc.\n\n\nData Controller usually don't have a route, but can be mapped to a dedicated route, that makes Flamingo return data as JSON content type.\n\n\nExamples\n\n\nAs always an example illustrates the routing concept best, so here we have it:\n(\nmodule.go\n)\n\n\nfunc (m *Module) Configure(injector *dingo.Injector) {\n    // Register the controller\n    m.RouterRegistry.Handle(\nsearch.search\n, new(interfaces.ViewController))\n\n    // Map `/search` to ViewController with `type` set to `product`\n    m.RouterRegistry.Route(\n/search\n, `search.search(type=\nproduct\n)`)\n\n    // Map `/search/:type` to ViewController with `type` retrieved from the path\n    m.RouterRegistry.Route(\n/search/:type\n, `search.search(type)`)\n\n    // Map a controller action to a router (no METHOD specific handling)\n    m.RouterRegistry.Handle(\nflamingo.redirect\n, (*controller.Redirect).Redirect)\n}\n\n\n\n\nRoute Format\n\n\nThe route format is based on the format the \nPlay Framework\n is using.\n\n\nEssentially there are 4 types of parts, of which the route is constructed\n\n\nStatic\n\n\nA piece which is just static, such as \n/foo/bar/asd\n.\n\n\nParameter\n\n\nA part with a named parameter, \n/foo/:param/\n which spans the request up to the next \n/\n or \n.\n (e.g. \n.html\n).\n\n\nRegex\n\n\nA (optionally named) regex parameter such as \n/foo/$param\n[0-9]+\n which captures everything the regex captures, where \nparam\n in this example is the name of the parameter.\n\n\nWildcard\n\n\nA wildcard which captures everything, such as \n/foo/bar/*param\n. Note that slashes are not escaped here!\n\n\nRouter Target\n\n\nThe target of a route is a controller name and optional attributes.\n\n\nParameters\n\n\nParameters are comma-separated identifiers.\n\n\nIf no parameters are specified and not brackets are used every route parameter is available as a parameter.\n\n\n\n\ncontroller.view\n Get's all available parameters\n\n\ncontroller.view(param1, param2)\n param1 and param2 will be set\n\n\ncontroller.view(param1 ?= \"foo\", param2 = \"bar\")\n param1 is optional, if not specified it is set to \"foo\". param2 is always set to \"bar\".\n\n\n\n\nIf specified parameters don't have a value or optional value and are not part of the path, then they are taken from GET parameters.\n\n\nCatchall\n\n\nIt is possible to specify a catchall address, which gets all parameters and applies all \"leftover\" as GET parameters, use \n*\n to indicate a catchall.\n\n\nExample:\n\n\ncontroller.view(param1, *)\n\n\nThis is quite helpful for reverse-routing.\n\n\nRegistering routes and controllers\n\n\nRoutes and controllers are registered at the \nrouter.Registry\n.\n\n\nMap a name to a controller\n\n\nregistry.Handle(\ncontroller.name\n, new(controllers.ControllerName))\n\n\n\n\nMap a name to a controller action\n\n\nThis is necessary if you don't want a controller with Method-based matching, and instead register an action for all requests to this controller.\nFlamingo takes care of injecting dependencies in the new-generated controller instance.\n\n\nregistry.Handle(\ncontroller.Name\n, (*controllers.ControllerName).Action)\n\n\n\n\nMap a route to a controller\n\n\nregistry.Route(\n/path/to/something\n, \ncontroller.name\n)\n\n\n\n\nThe name will be \npath.to.something\n (outer slashes are stripped, then slashes will be converted to dots).\n\n\nDefault Controller\n\n\nCurrently Flamingo registers the following controller:\n\n\n\n\nflamingo.redirect(to, ...)\n Redirects to \nto\n. All other parameters (but \nto\n) are passed on as URL parameters \n\n\nflamingo.redirectUrl(url)\n Redirects to \nurl\n \n\n\nflamingo.redirectPermanent(to, ...)\n Redirects permanently to \nto\n. All other parameters (but \nto\n) are passed on as URL parameters \n\n\nflamingo.redirectPermanentUrl(url)\n Redirects permanently to \nurl\n \n\n\n\n\nContext routes\n\n\nBeside registering routes in the code it is also possible to register them in your context.yml.\n\n\nThe root node \nroutes\n consists of an array of objects with:\n\n\n\n\ncontroller\n: must name a controller to execute\n\n\npath\n: optional path where this is accessable\n\n\nname\n: optional name where this will be available for reverse routing\n\n\n\n\nContext routes always take precedence over normal routes!\n\n\nExample\n\n\nroutes:\n  - path: /\n    controller: flamingo.redirect(to=\ncms.page.view\n, name=\nhome\n)\n    name: home\n  - path: /home\n    controller: cms.page.view(name=\nhome\n)\n  - path: /special\n    controller: cms.page.view(name?=\nspecial\n)\n\n\n\n\nThis will result in the following accessable routes:\n\n\n\n\n/\n: Redirects to \n/home\n (because there is a route for \ncms.page.view\n with \nname\n set to \nhome\n. Otherwise this would go to \n/cms/home\n)\n\n\n/home\n: Shows \ncms.page.view(name=\"home\")\n\n\n/special\n: Shows \ncms.page.view(name=\"special\")\n\n\n/special?name=foo\n: Shows \ncms.page.view(name=\"foo\")\n (optional argument retrieved from GET)\n\n\n\n\nThe \n/\n route is now also available as a controller named \nhome\n, which is just an alias for calling the \nflamingo.redirect\n controller with the parameters \nto=\"cms.page.view\"\n and \nname=\"home\"\n.\n\n\nRouter filter\n\n\nRouter filters can be used as middleware in the dispatching process. The filters are executed before the controller action.\nA router filter can be registered via dingo injection in \nmodule.go\n's Configure function:\n\n\nfunc (m *Module) Configure(injector *dingo.Injector) {\n\n    injector.BindMulti((*router.Filter)(nil)).To(myFilter{})\n\n}\n\n\n\n\nA Filter must implement the \nrouter.Filter\n interface by providing a Filter function: \nFilter(ctx web.Context, w http.ResponseWriter, fc *FilterChain) web.Response\n.\n\n\nThe filters are handled in order of \ndingo.Modules\n as defined in \nflamingo.App()\n call.\nYou will have to return \nchain.Next(ctx, w)\n in your \nFilter\n function to call the next filter. If you return something else,\nthe chain will be aborted and the actual controller action will not be executed.", 
            "title": "Routing"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#routing", 
            "text": "", 
            "title": "Routing"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#routing-concept", 
            "text": "The URL structure in flamingo consists of a baseurl + the rest of the url.\nThe baseurl is matched against the configured contexts and determines the context that should be loaded.  For the part of the url behind the baseurl (=path) a standard routing concept is applied, where at the end the URL is matched to a controller.   a route is assigned to a handle. (A handle is a string that represents a unique name). A handle can be something like \"cms.page.view\"  for a handle a Controller can be registered. The indirection through handles allows us to register different controllers for certain handlers in different contexts.   Routes can be configured the following ways:  Via  router.Registry  in  module.go   As part of the project configuration. This again allows us to have different routing paths configured for different contexts.", 
            "title": "Routing concept"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#route", 
            "text": "A route defines a mapping from a path to an handler identifier.  The handler identifier is used to easily support reverse routing and rewriting mechanisms.", 
            "title": "Route"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#handler", 
            "text": "A handler is defined by mapping a path to a  http.Handler  or a controller.", 
            "title": "Handler"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#controller-types", 
            "text": "http.Handler : will call  ServeHTTP  for requests matching the route  GETController : will call  Get(web.Context) web.Response  for  GET  Requests  POSTController : will call  Post(web.Context) web.Response  for  POST  Requests  HEADController : will call  Head(web.Context) web.Response  for  HEAD  Requests  DELETEController : will call  Delete(web.Context) web.Response  for  DELETE  Requests  PUTController : will call  Put(web.Context) web.Response  for  PUT  Requests  func(web.Context) web.Response : called for any Request  DataController : will call  Data(web.Context) interface{}  for Data requests  func(web.Context) interface{} : for Data requests", 
            "title": "Controller types"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#data-controller", 
            "text": "Views can request arbitrary data via the  get  template function.  Flamingo exposes these data controllers via their logical name at  /_flamingo/json?name=... .\nThis is a default feature for Ajax-based cache holepunching etc.  Data Controller usually don't have a route, but can be mapped to a dedicated route, that makes Flamingo return data as JSON content type.", 
            "title": "Data Controller"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#examples", 
            "text": "As always an example illustrates the routing concept best, so here we have it:\n( module.go )  func (m *Module) Configure(injector *dingo.Injector) {\n    // Register the controller\n    m.RouterRegistry.Handle( search.search , new(interfaces.ViewController))\n\n    // Map `/search` to ViewController with `type` set to `product`\n    m.RouterRegistry.Route( /search , `search.search(type= product )`)\n\n    // Map `/search/:type` to ViewController with `type` retrieved from the path\n    m.RouterRegistry.Route( /search/:type , `search.search(type)`)\n\n    // Map a controller action to a router (no METHOD specific handling)\n    m.RouterRegistry.Handle( flamingo.redirect , (*controller.Redirect).Redirect)\n}", 
            "title": "Examples"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#route-format", 
            "text": "The route format is based on the format the  Play Framework  is using.  Essentially there are 4 types of parts, of which the route is constructed", 
            "title": "Route Format"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#static", 
            "text": "A piece which is just static, such as  /foo/bar/asd .", 
            "title": "Static"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#parameter", 
            "text": "A part with a named parameter,  /foo/:param/  which spans the request up to the next  /  or  .  (e.g.  .html ).", 
            "title": "Parameter"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#regex", 
            "text": "A (optionally named) regex parameter such as  /foo/$param [0-9]+  which captures everything the regex captures, where  param  in this example is the name of the parameter.", 
            "title": "Regex"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#wildcard", 
            "text": "A wildcard which captures everything, such as  /foo/bar/*param . Note that slashes are not escaped here!", 
            "title": "Wildcard"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#router-target", 
            "text": "The target of a route is a controller name and optional attributes.", 
            "title": "Router Target"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#parameters", 
            "text": "Parameters are comma-separated identifiers.  If no parameters are specified and not brackets are used every route parameter is available as a parameter.   controller.view  Get's all available parameters  controller.view(param1, param2)  param1 and param2 will be set  controller.view(param1 ?= \"foo\", param2 = \"bar\")  param1 is optional, if not specified it is set to \"foo\". param2 is always set to \"bar\".   If specified parameters don't have a value or optional value and are not part of the path, then they are taken from GET parameters.", 
            "title": "Parameters"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#catchall", 
            "text": "It is possible to specify a catchall address, which gets all parameters and applies all \"leftover\" as GET parameters, use  *  to indicate a catchall.  Example:  controller.view(param1, *)  This is quite helpful for reverse-routing.", 
            "title": "Catchall"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#registering-routes-and-controllers", 
            "text": "Routes and controllers are registered at the  router.Registry .", 
            "title": "Registering routes and controllers"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#map-a-name-to-a-controller", 
            "text": "registry.Handle( controller.name , new(controllers.ControllerName))", 
            "title": "Map a name to a controller"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#map-a-name-to-a-controller-action", 
            "text": "This is necessary if you don't want a controller with Method-based matching, and instead register an action for all requests to this controller.\nFlamingo takes care of injecting dependencies in the new-generated controller instance.  registry.Handle( controller.Name , (*controllers.ControllerName).Action)", 
            "title": "Map a name to a controller action"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#map-a-route-to-a-controller", 
            "text": "registry.Route( /path/to/something ,  controller.name )  The name will be  path.to.something  (outer slashes are stripped, then slashes will be converted to dots).", 
            "title": "Map a route to a controller"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#default-controller", 
            "text": "Currently Flamingo registers the following controller:   flamingo.redirect(to, ...)  Redirects to  to . All other parameters (but  to ) are passed on as URL parameters   flamingo.redirectUrl(url)  Redirects to  url    flamingo.redirectPermanent(to, ...)  Redirects permanently to  to . All other parameters (but  to ) are passed on as URL parameters   flamingo.redirectPermanentUrl(url)  Redirects permanently to  url", 
            "title": "Default Controller"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#context-routes", 
            "text": "Beside registering routes in the code it is also possible to register them in your context.yml.  The root node  routes  consists of an array of objects with:   controller : must name a controller to execute  path : optional path where this is accessable  name : optional name where this will be available for reverse routing   Context routes always take precedence over normal routes!", 
            "title": "Context routes"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#example", 
            "text": "routes:\n  - path: /\n    controller: flamingo.redirect(to= cms.page.view , name= home )\n    name: home\n  - path: /home\n    controller: cms.page.view(name= home )\n  - path: /special\n    controller: cms.page.view(name?= special )  This will result in the following accessable routes:   / : Redirects to  /home  (because there is a route for  cms.page.view  with  name  set to  home . Otherwise this would go to  /cms/home )  /home : Shows  cms.page.view(name=\"home\")  /special : Shows  cms.page.view(name=\"special\")  /special?name=foo : Shows  cms.page.view(name=\"foo\")  (optional argument retrieved from GET)   The  /  route is now also available as a controller named  home , which is just an alias for calling the  flamingo.redirect  controller with the parameters  to=\"cms.page.view\"  and  name=\"home\" .", 
            "title": "Example"
        }, 
        {
            "location": "/2. Framework Features/routing/index.html#router-filter", 
            "text": "Router filters can be used as middleware in the dispatching process. The filters are executed before the controller action.\nA router filter can be registered via dingo injection in  module.go 's Configure function:  func (m *Module) Configure(injector *dingo.Injector) {\n\n    injector.BindMulti((*router.Filter)(nil)).To(myFilter{})\n\n}  A Filter must implement the  router.Filter  interface by providing a Filter function:  Filter(ctx web.Context, w http.ResponseWriter, fc *FilterChain) web.Response .  The filters are handled in order of  dingo.Modules  as defined in  flamingo.App()  call.\nYou will have to return  chain.Next(ctx, w)  in your  Filter  function to call the next filter. If you return something else,\nthe chain will be aborted and the actual controller action will not be executed.", 
            "title": "Router filter"
        }, 
        {
            "location": "/2. Framework Features/sessions/index.html", 
            "text": "Sessions\n\n\nGeneral session usage\n\n\nSession handling in Flamingo is bound to the \nweb.Context\n.\n\n\nweb.Context\n has a \nSession()\n method returning a \ngorilla.Session\n object, which\nthe programmer can assume is properly persisted and handled.\n\n\nSessions have a \nValues\n map of type \nmap[string]interface{}\n, which can be used to store arbitrary data.\n\n\nHowever, it is important to know that underlying \ngob\n is used, so it might be necessary to register\nyour custom types via \ngob.Register(MyStruct{})\n in your module's \nConfigure\n method if you\nwant to make sure it is properly persisted.\n\n\nPersistence is done automatically if you use \nValues\n.\n\n\nAuthentication\n\n\nFlamingo's \ncore/auth\n module provides basic OpenID connect authentication.\n\n\nGiven that the module is used in your project (that means registered) you can inject\nthe \napplication.AuthManager\n in your controller, and use that to retrieve\nUser information from the context.\n\n\nPlease note: the auth package needs a proper session backend like redis, the cookie\nbackend does not provide enough space for jwt tokens.\n\n\nimport (\n    \ngo.aoe.com/flamingo/core/auth/application\n\n    \ngo.aoe.com/flamingo/core/auth/domain\n\n)\n\ntype Controller struct {\n    AuthManager *application.AuthManager `inject:\n`\n}\n\nfunc (c *Controller) Get(ctx web.Context) web.Response {\n    token, err := c.AuthManager.IdToken(ctx)\n    // ...\n    user := domain.UserFromIDToken(token)  // user contains the User information obtained from the ID token\n\n    client, err := c.AuthManager.HttpClient(ctx)\n    /*\n     * client is of type http.Client, and provides\n     * a basic http client functionality.\n     * If the context belongs to a logged in user\n     * then all requests done via this client will have\n     * automatically the current OAuth2 Access Token assigned\n     */\n}\n\n\n\n\nConfiguration\n\n\nFlamingo expects a \nsession.Store\n dingo binding, this is currently handled via the \nsession.backend\n config parameter.\n\n\nPossible values are currently \nfile\n for temporary file storage and \nredis\n for a redis backend.\n\n\nThe redis backend uses the config param \nsession.backend.redis.host\n to find the redis, e.g. \nredis.host:6379\n.", 
            "title": "Sessions"
        }, 
        {
            "location": "/2. Framework Features/sessions/index.html#sessions", 
            "text": "", 
            "title": "Sessions"
        }, 
        {
            "location": "/2. Framework Features/sessions/index.html#general-session-usage", 
            "text": "Session handling in Flamingo is bound to the  web.Context .  web.Context  has a  Session()  method returning a  gorilla.Session  object, which\nthe programmer can assume is properly persisted and handled.  Sessions have a  Values  map of type  map[string]interface{} , which can be used to store arbitrary data.  However, it is important to know that underlying  gob  is used, so it might be necessary to register\nyour custom types via  gob.Register(MyStruct{})  in your module's  Configure  method if you\nwant to make sure it is properly persisted.  Persistence is done automatically if you use  Values .", 
            "title": "General session usage"
        }, 
        {
            "location": "/2. Framework Features/sessions/index.html#authentication", 
            "text": "Flamingo's  core/auth  module provides basic OpenID connect authentication.  Given that the module is used in your project (that means registered) you can inject\nthe  application.AuthManager  in your controller, and use that to retrieve\nUser information from the context.  Please note: the auth package needs a proper session backend like redis, the cookie\nbackend does not provide enough space for jwt tokens.  import (\n     go.aoe.com/flamingo/core/auth/application \n     go.aoe.com/flamingo/core/auth/domain \n)\n\ntype Controller struct {\n    AuthManager *application.AuthManager `inject: `\n}\n\nfunc (c *Controller) Get(ctx web.Context) web.Response {\n    token, err := c.AuthManager.IdToken(ctx)\n    // ...\n    user := domain.UserFromIDToken(token)  // user contains the User information obtained from the ID token\n\n    client, err := c.AuthManager.HttpClient(ctx)\n    /*\n     * client is of type http.Client, and provides\n     * a basic http client functionality.\n     * If the context belongs to a logged in user\n     * then all requests done via this client will have\n     * automatically the current OAuth2 Access Token assigned\n     */\n}", 
            "title": "Authentication"
        }, 
        {
            "location": "/2. Framework Features/sessions/index.html#configuration", 
            "text": "Flamingo expects a  session.Store  dingo binding, this is currently handled via the  session.backend  config parameter.  Possible values are currently  file  for temporary file storage and  redis  for a redis backend.  The redis backend uses the config param  session.backend.redis.host  to find the redis, e.g.  redis.host:6379 .", 
            "title": "Configuration"
        }, 
        {
            "location": "/3. Core Packages/pug-template/index.html", 
            "text": "Pug Template\n\n\npug.js\n\n\nPug\n is a JavaScript template rendering engine.\n\n\nFlamingo Pug Template\n\n\nThe Flamingo \ncore/pug_template\n package is a flamingo template module to use pug.js templates.\n\n\nBasically pug.js is by default compiled to JavaScript, and executed as HTML.\n\n\nThis mechanism is used to render static prototypes for the templates, so the usual HTML prototype is\njust a natural artifact of this templating, instead of an extra workflow step or custom tool.\n\n\nThis allows frontend developers to start templating very early with very few backend supports,\nyet without the need to rewrite everything or even learn a new template language.\n\n\nAlso the static prototype can be used to test/analyze the UI in early project phases, while the backend\nmight not be done yet.\n\n\nThe way pug.js works is essentially this:\n\n\ntemplate -[tokenizer]-\n tokens -[parser]-\n AST -[compiler]-\n JavaScript -[runtime]-\n HTML\n\n\n\n\nTo integrate this with Flamingo we save the AST (Abstract syntax tree) in a json representation.\npug_template will use a parser to build an internal in-memory tree of the concrete building\nblocks, and then use a render to transform these blocks into actual go template with HTML.\n\n\nAST -[parser]-\n Block tree -[render]-\n go template -[go-template-runtime]-\n HTML\n\n\n\n\n(You can also view the intermediate result https://flamingoURL/_pugtpl/debug?tpl=home/home)\n\n\nOne of the features of pug.js is the posibility to use arbitrary JavaScript in case the template syntax\ndoes not provide the correct funtions. This is used for example in loops like\n\n\nul\n  each val, index in ['zero', 'one', 'two']\n    li= index + ': ' + val\n\n\n\n\nThe term \n['zero', 'one', 'two']\n is actual JavaScript, and a developer is able to use more advanced\ncode like\n\n\n- prefix = 'foo'\nul\n  each val, index in [prefix+'zero', prefix+'one', prefix+'two']\n    li= index + ': ' + val\n\n\n\n\nThe pug_template module takes this JavaScript and uses the go-bases JS engine otto to parse the JavaScript\nand transpile it into actual go code.\nWhile this works for some standard statements and language constructs (default datatypes such as maps, list, etc),\nthis does not support certain things such as OOP or the JS stdlib.\n\n\nIt is, however, possible to recreate such functionality in a third-party module via Flamingo's template functions.\nFor example pug_template itself has a substitute for the JavaScript \nMath\n library with the \nmin\n, \nmax\n and \nceil\n\nfunctions. Please note that these function have to use reflection and it's up to the implementation to properly\nreflect the functionality and handle different inputs correctly.\n\n\nAfter all extensive usage of JavaScript is not advised.\n\n\nDynamic JavaScript\n\n\nThe Pug Template engine compiles a subset of JavaScript (ES2015) to Go templates.\nThis allows frontend developers to use known workflows and techniques, instead of learning\na complete new template engine.\n\n\nTo make this possible Flamingo rewrites the JavaScript to go, on the fly.\n\n\nSupported JavaScript\n\n\nStandard Datatypes\n\n\n{\nkey\n: \nvalue\n}\n\n\nstring\n + \nanother string\n\n\n1 + 2\n\n15 * 8\n\n[1, 2, 3, 4, 5]\n\n\n\n\nSupport Pug\n\n\nInterpolation\n\n\np Text #{variable} something #{1 + 2}\n\n\n\n\nMixins\n\n\nmixin mymixin(arg1, arg2=\ndefault)\n  p.something(id=arg2)= arg1\n\n+mymixing(\nfoo\n)\n\n+mymixin(\nfoo\n, \nbar\n)\n\n\n\n\nLoops\n\n\neach value, index in  [\na\n, \nb\n, \nc\n]\n  p value #{value} at #{index}\n\n\n\n\nDebugging\n\n\nTemplates can be debugged via \n/_pugtpl/debug?tpl=pages/product/view", 
            "title": "Pug Template"
        }, 
        {
            "location": "/3. Core Packages/pug-template/index.html#pug-template", 
            "text": "", 
            "title": "Pug Template"
        }, 
        {
            "location": "/3. Core Packages/pug-template/index.html#pugjs", 
            "text": "Pug  is a JavaScript template rendering engine.", 
            "title": "pug.js"
        }, 
        {
            "location": "/3. Core Packages/pug-template/index.html#flamingo-pug-template", 
            "text": "The Flamingo  core/pug_template  package is a flamingo template module to use pug.js templates.  Basically pug.js is by default compiled to JavaScript, and executed as HTML.  This mechanism is used to render static prototypes for the templates, so the usual HTML prototype is\njust a natural artifact of this templating, instead of an extra workflow step or custom tool.  This allows frontend developers to start templating very early with very few backend supports,\nyet without the need to rewrite everything or even learn a new template language.  Also the static prototype can be used to test/analyze the UI in early project phases, while the backend\nmight not be done yet.  The way pug.js works is essentially this:  template -[tokenizer]-  tokens -[parser]-  AST -[compiler]-  JavaScript -[runtime]-  HTML  To integrate this with Flamingo we save the AST (Abstract syntax tree) in a json representation.\npug_template will use a parser to build an internal in-memory tree of the concrete building\nblocks, and then use a render to transform these blocks into actual go template with HTML.  AST -[parser]-  Block tree -[render]-  go template -[go-template-runtime]-  HTML  (You can also view the intermediate result https://flamingoURL/_pugtpl/debug?tpl=home/home)  One of the features of pug.js is the posibility to use arbitrary JavaScript in case the template syntax\ndoes not provide the correct funtions. This is used for example in loops like  ul\n  each val, index in ['zero', 'one', 'two']\n    li= index + ': ' + val  The term  ['zero', 'one', 'two']  is actual JavaScript, and a developer is able to use more advanced\ncode like  - prefix = 'foo'\nul\n  each val, index in [prefix+'zero', prefix+'one', prefix+'two']\n    li= index + ': ' + val  The pug_template module takes this JavaScript and uses the go-bases JS engine otto to parse the JavaScript\nand transpile it into actual go code.\nWhile this works for some standard statements and language constructs (default datatypes such as maps, list, etc),\nthis does not support certain things such as OOP or the JS stdlib.  It is, however, possible to recreate such functionality in a third-party module via Flamingo's template functions.\nFor example pug_template itself has a substitute for the JavaScript  Math  library with the  min ,  max  and  ceil \nfunctions. Please note that these function have to use reflection and it's up to the implementation to properly\nreflect the functionality and handle different inputs correctly.  After all extensive usage of JavaScript is not advised.", 
            "title": "Flamingo Pug Template"
        }, 
        {
            "location": "/3. Core Packages/pug-template/index.html#dynamic-javascript", 
            "text": "The Pug Template engine compiles a subset of JavaScript (ES2015) to Go templates.\nThis allows frontend developers to use known workflows and techniques, instead of learning\na complete new template engine.  To make this possible Flamingo rewrites the JavaScript to go, on the fly.", 
            "title": "Dynamic JavaScript"
        }, 
        {
            "location": "/3. Core Packages/pug-template/index.html#supported-javascript", 
            "text": "", 
            "title": "Supported JavaScript"
        }, 
        {
            "location": "/3. Core Packages/pug-template/index.html#standard-datatypes", 
            "text": "{ key :  value } string  +  another string \n\n1 + 2\n\n15 * 8\n\n[1, 2, 3, 4, 5]", 
            "title": "Standard Datatypes"
        }, 
        {
            "location": "/3. Core Packages/pug-template/index.html#support-pug", 
            "text": "", 
            "title": "Support Pug"
        }, 
        {
            "location": "/3. Core Packages/pug-template/index.html#interpolation", 
            "text": "p Text #{variable} something #{1 + 2}", 
            "title": "Interpolation"
        }, 
        {
            "location": "/3. Core Packages/pug-template/index.html#mixins", 
            "text": "mixin mymixin(arg1, arg2= default)\n  p.something(id=arg2)= arg1\n\n+mymixing( foo )\n\n+mymixin( foo ,  bar )", 
            "title": "Mixins"
        }, 
        {
            "location": "/3. Core Packages/pug-template/index.html#loops", 
            "text": "each value, index in  [ a ,  b ,  c ]\n  p value #{value} at #{index}", 
            "title": "Loops"
        }, 
        {
            "location": "/3. Core Packages/pug-template/index.html#debugging", 
            "text": "Templates can be debugged via  /_pugtpl/debug?tpl=pages/product/view", 
            "title": "Debugging"
        }, 
        {
            "location": "/4. Others/FAQ/index.html", 
            "text": "FAQ\n\n\nI can't update my dependencies\n\n\nDelete the \nvendor/\n folder.\n\n\nom3? core? framework? Where to put my code?\n\n\nDepends on where it is supposed to live, use your experience in programming to decide :)\n\n\nThread structure\n\n\nTODO", 
            "title": "FAQ"
        }, 
        {
            "location": "/4. Others/FAQ/index.html#faq", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/4. Others/FAQ/index.html#i-cant-update-my-dependencies", 
            "text": "Delete the  vendor/  folder.", 
            "title": "I can't update my dependencies"
        }, 
        {
            "location": "/4. Others/FAQ/index.html#om3-core-framework-where-to-put-my-code", 
            "text": "Depends on where it is supposed to live, use your experience in programming to decide :)", 
            "title": "om3? core? framework? Where to put my code?"
        }, 
        {
            "location": "/4. Others/FAQ/index.html#thread-structure", 
            "text": "TODO", 
            "title": "Thread structure"
        }
    ]
}